# Generated by Django 5.2.6 on 2025-11-17 09:34

from __future__ import annotations

from collections import defaultdict
from datetime import datetime

from django.conf import settings
from django.db import migrations
from django.utils import timezone
from django.utils.dateparse import parse_datetime


def _parse_timestamp(value: str | None) -> datetime | None:
    if not value:
        return None
    candidate = str(value).strip()
    if not candidate:
        return None
    parsed = parse_datetime(candidate)
    if parsed is not None:
        if timezone.is_naive(parsed):
            parsed = timezone.make_aware(parsed, timezone.utc)
        return parsed
    try:
        as_float = float(candidate)
    except (TypeError, ValueError):
        return None
    return datetime.fromtimestamp(as_float, tz=timezone.utc)


def _resolve_tenant(apps, schema_name: str):
    Tenant = apps.get_model("customers", "Tenant")
    if not schema_name or schema_name == getattr(settings, "PUBLIC_SCHEMA_NAME", "public"):
        return None
    try:
        return Tenant.objects.get(schema_name=schema_name)
    except Tenant.DoesNotExist:
        return None


def _build_payload(run) -> dict[str, object]:
    return {
        "status": run.status,
        "run_id": run.run_id,
        "error": run.error,
        "inserted_documents": run.inserted_documents,
        "replaced_documents": run.replaced_documents,
        "skipped_documents": run.skipped_documents,
        "inserted_chunks": run.inserted_chunks,
    }


def backfill_cases(apps, schema_editor):
    Case = apps.get_model("cases", "Case")
    CaseEvent = apps.get_model("cases", "CaseEvent")
    Run = apps.get_model("documents", "DocumentIngestionRun")
    schema_name = getattr(schema_editor.connection, "schema_name", None)
    tenant = _resolve_tenant(apps, schema_name)
    if tenant is None:
        return

    runs = (
        Run.objects.exclude(case__isnull=True)
        .exclude(case__exact="")
        .order_by("case", "queued_at", "started_at")
    )
    case_map: dict[str, dict[str, object]] = defaultdict(lambda: {"runs": [], "earliest": None})
    for run in runs:
        case_id = (run.case or "").strip()
        if not case_id:
            continue
        entry = case_map[case_id]
        entry["runs"].append(run)
        for stamp in (run.queued_at, run.started_at):
            parsed = _parse_timestamp(stamp)
            if parsed is None:
                continue
            earliest = entry["earliest"]
            if earliest is None or parsed < earliest:
                entry["earliest"] = parsed

    if not case_map:
        return

    for external_id, payload in case_map.items():
        case, created = Case.objects.get_or_create(
            tenant=tenant,
            external_id=external_id,
            defaults={"status": Case.Status.OPEN},
        )
        created_at = payload.get("earliest")
        if created and created_at:
            Case.objects.filter(pk=case.pk).update(
                created_at=created_at,
                updated_at=created_at,
            )

        for run in payload["runs"]:
            CaseEvent.objects.get_or_create(
                tenant=tenant,
                case=case,
                ingestion_run=run,
                event_type="ingestion_run_migrated",
                defaults={
                    "source": "migration",
                    "collection_id": run.collection_id,
                    "trace_id": run.trace_id,
                    "payload": _build_payload(run),
                },
            )


def noop(apps, schema_editor):  # pragma: no cover - required by migrations API
    return None


class Migration(migrations.Migration):

    dependencies = [
        ("cases", "0001_initial"),
        ("documents", "0003_rename_documentingestionrun_tenant_id"),
        ("customers", "0005_tenant_pii_deterministic_tenant_pii_hmac_secret_and_more"),
    ]

    operations = [migrations.RunPython(backfill_cases, reverse_code=noop)]
