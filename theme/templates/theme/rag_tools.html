{% extends 'theme/base.html' %}
{% load static %}

{% block title %}RAG Tools · NOESIS 2{% endblock %}

{% block head %}
{{ block.super }}
<script src="{% static 'theme/rag-tools-support.js' %}"></script>
{% endblock %}

{% block content %}
<div class="space-y-10">
  <header class="space-y-2">
    <h1 class="text-3xl font-semibold tracking-tight text-slate-900">RAG Manual Testing</h1>
    <p class="max-w-2xl text-sm text-slate-600">
      Nutze diese Werkbank, um Dateien hochzuladen und Queries gegen die bestehenden RAG-Endpunkte abzufeuern.
      Alle Requests senden automatisch die aus der aktuellen Domain abgeleiteten Header
      <code class="rounded bg-slate-100 px-1 py-0.5 text-xs">X-Tenant-ID: {{ tenant_id }}</code>,
      <code class="rounded bg-slate-100 px-1 py-0.5 text-xs">X-Tenant-Schema: {{ tenant_schema }}</code>,
      <code class="rounded bg-slate-100 px-1 py-0.5 text-xs">X-User-ID: local</code>
      und
      <code class="rounded bg-slate-100 px-1 py-0.5 text-xs">X-Case-ID: local</code>.
    </p>
  </header>

  <section class="rounded-lg border border-slate-200 bg-white p-6 shadow-sm space-y-6">
    <div class="space-y-2">
      <h2 class="text-xl font-semibold text-slate-900">Web Search</h2>
      <p class="text-sm text-slate-600">
        Teste den <code class="rounded bg-slate-100 px-1 py-0.5 text-xs">WebSearchWorker</code> (Google Adapter).
        Die Anfrage wird via AJAX an diese View gesendet.
      </p>
    </div>

    <form id="web-search-form" class="space-y-4">
      {% csrf_token %}
      <div class="space-y-1">
        <label class="text-sm font-medium text-slate-700" for="web-search-query">Search Query</label>
        <input
          class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
          id="web-search-query"
          name="query"
          type="text"
          placeholder="z. B. aktuelle regulatorische Änderungen Banken"
          required
        />
      </div>
      <button
        class="inline-flex items-center rounded-md bg-slate-900 px-4 py-2 text-sm font-medium text-white shadow-sm transition hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-offset-2"
        type="submit"
        id="web-search-button"
      >
        Suche starten
      </button>
    </form>

    <div class="space-y-3">
      <div
        id="web-search-error"
        class="hidden rounded-md border border-red-200 bg-red-50 p-3 text-sm text-red-700"
      ></div>
      <div class="space-y-3" id="web-search-results">
         <p class="text-sm text-slate-500">Noch keine Suche durchgeführt.</p>
      </div>
    </div>

    <div class="space-y-2">
      <h3 class="text-sm font-semibold uppercase tracking-wide text-slate-600">Web Search Raw Response</h3>
      <pre class="max-h-64 overflow-auto rounded-lg bg-slate-950 p-4 text-xs text-slate-100" id="web-search-raw"></pre>
    </div>
  </section>

  <section class="rounded-lg border border-slate-200 bg-white p-6 shadow-sm space-y-6">
    <div class="space-y-2">
      <h2 class="text-xl font-semibold text-slate-900">Crawler Runner</h2>
      <p class="text-sm text-slate-600">
        Starte den neuen LangGraph-Crawler mit beliebigen Inhalten, steuere Shadow- und Dry-Run-Modi
        und entscheide manuell über Ingestion-Freigaben. Der Request nutzt automatisch die aktiven Tenant-Header.
      </p>
    </div>

    <form id="crawler-form" class="grid gap-4 md:grid-cols-2">
      <div class="space-y-1">
        <label class="text-sm font-medium text-slate-700" for="crawler-workflow">Workflow ID</label>
        <input
          class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
          id="crawler-workflow"
          name="workflow_id"
          type="text"
          value="{{ crawler_default_workflow_id }}"
          placeholder="crawler-demo"
        />
      </div>
      <div class="space-y-1">
        <label class="text-sm font-medium text-slate-700" for="crawler-mode">Modus</label>
        <select
          id="crawler-mode"
          name="mode"
          class="block w-full rounded-md border border-slate-300 bg-white px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
        >
          <option value="ingest" selected>Ingest (Fetch · Store · Upsert)</option>
          <option value="store_only">Store only (Fetch · Store)</option>
          <option value="fetch_only">Fetch only (Analyse ohne Storage)</option>
        </select>
        <p class="text-xs text-slate-500">Steuert, ob der Lauf nur Fetch, Fetch+Store oder den kompletten Ingestion-Pfad inklusive Upsert ausführt.</p>
      </div>
      <div class="space-y-1">
        <label class="text-sm font-medium text-slate-700" for="crawler-origin">Origin URL</label>
        <input
          class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
          id="crawler-origin"
          name="origin_url"
          type="url"
          placeholder="https://example.com/docs"
          required
        />
      </div>
      <div class="md:col-span-2 space-y-1">
        <div class="flex items-center justify-between gap-2">
          <label class="text-sm font-medium text-slate-700" for="crawler-origin-list">Weitere URLs (optional)</label>
          <span class="text-xs text-slate-500">Eine pro Zeile oder Komma-getrennt</span>
        </div>
        <textarea
          class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
          id="crawler-origin-list"
          name="origin_urls"
          rows="3"
          placeholder="https://example.com/docs/handbook\nhttps://example.com/docs/policies"
        ></textarea>
        <p class="text-xs text-slate-500">Wenn gesetzt, werden alle angegebenen Origins gemeinsam mit den globalen Optionen ausgeführt.</p>
      </div>
      <div class="space-y-1">
        <label class="text-sm font-medium text-slate-700" for="crawler-title">Titel (optional)</label>
        <input
          class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
          id="crawler-title"
          name="title"
          type="text"
        />
      </div>
      <div class="space-y-1">
        <label class="text-sm font-medium text-slate-700" for="crawler-language">Sprache</label>
        <input
          class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
          id="crawler-language"
          name="language"
          type="text"
          placeholder="de"
        />
      </div>
      <div class="space-y-1">
        <label class="text-sm font-medium text-slate-700" for="crawler-provider">Provider</label>
        <input
          class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
          id="crawler-provider"
          name="provider"
          type="text"
          value="web"
        />
      </div>
      <div class="space-y-1">
        <label class="text-sm font-medium text-slate-700" for="crawler-tags">Tags</label>
        <input
          class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
          id="crawler-tags"
          name="tags"
          type="text"
          placeholder="handbook,hr"
        />
      </div>
      <div class="md:col-span-2 space-y-1">
        <label class="text-sm font-medium text-slate-700" for="crawler-collection">Collection ID</label>
        <input
          class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
          id="crawler-collection"
          name="collection_id"
          type="search"
          list="query-collection-options"
          autocomplete="off"
          placeholder="z. B. 123e4567-e89b-12d3-a456-426614174000"
        />
        <p class="text-xs text-slate-500">Optional: Überschreibt die aktive Resolver-Collection nur für diesen Lauf.</p>
      </div>
      <div class="space-y-1">
        <label class="text-sm font-medium text-slate-700" for="crawler-content-type">Content Type</label>
        <input
          class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
          id="crawler-content-type"
          name="content_type"
          type="text"
          value="text/html"
        />
      </div>
      <div class="space-y-1">
        <label class="text-sm font-medium text-slate-700" for="crawler-max-bytes">Max Document Bytes</label>
        <input
          class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
          id="crawler-max-bytes"
          name="max_document_bytes"
          type="number"
          min="0"
        />
        <p class="text-xs text-slate-500">Optional: kleiner Wert löst einen Manual-Review-Pfad aus.</p>
      </div>
      <div class="space-y-1">
        <label class="text-sm font-medium text-slate-700" for="crawler-review">Review Status</label>
        <select
          id="crawler-review"
          name="review"
          class="block w-full rounded-md border border-slate-300 bg-white px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
          required
        >
          <option value="required" selected>Review erforderlich</option>
          <option value="approved">Bereits freigegeben</option>
          <option value="rejected">Bereits abgelehnt</option>
        </select>
        <p class="text-xs text-slate-500">Der Status steuert die Ingestion-Gating-Entscheidung und beeinflusst die Buttons zur manuellen Freigabe.</p>
      </div>
      <div class="md:col-span-2">
        <label class="inline-flex w-full cursor-pointer items-start gap-3 rounded-md border border-slate-200 bg-slate-50 px-3 py-2 text-sm text-slate-700" for="crawler-fetch">
          <input
            type="checkbox"
            id="crawler-fetch"
            class="mt-1 h-4 w-4 rounded border-slate-300 text-slate-900 focus:ring-slate-500"
            checked
          />
          <span class="flex flex-col gap-1">
            <span class="font-medium text-slate-800">Live fetch via URL</span>
            <span class="text-xs text-slate-500">Bei aktivem Live-Fetch wird der Inhalt direkt von der Origin-URL geladen. Deaktiviere den Schalter, um stattdessen manuell eingegebenen Content zu senden.</span>
          </span>
        </label>
      </div>
      <div id="crawler-content-wrapper" class="md:col-span-2 hidden space-y-1">
        <div class="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
          <label class="text-sm font-medium text-slate-700" for="crawler-content">Content</label>
          <span class="text-xs text-slate-500">HTML oder Plain Text</span>
        </div>
        <textarea
          class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
          id="crawler-content"
          name="content"
          rows="6"
        ></textarea>
      </div>
      <div class="md:col-span-2 space-y-2">
        <label class="inline-flex w-full cursor-pointer items-start gap-3 rounded-md border border-slate-200 bg-slate-50 px-3 py-2 text-sm text-slate-700" for="crawler-snapshot">
          <input
            type="checkbox"
            id="crawler-snapshot"
            class="mt-1 h-4 w-4 rounded border-slate-300 text-slate-900 focus:ring-slate-500"
          />
          <span class="flex flex-col gap-1">
            <span class="font-medium text-slate-800">Snapshot anlegen</span>
            <span class="text-xs text-slate-500">Erstellt eine HTML-Kopie des Inputs zur späteren Analyse. Aktivieren, wenn der Lauf dokumentiert werden soll.</span>
          </span>
        </label>
        <div id="crawler-snapshot-label-wrapper" class="hidden space-y-1">
          <label class="text-sm font-medium text-slate-700" for="crawler-snapshot-label">Snapshot Label (optional)</label>
          <input
            class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
            id="crawler-snapshot-label"
            name="snapshot_label"
            type="text"
            placeholder="z. B. live-debug"
            disabled
          />
          <p class="text-xs text-slate-500">Hinweis: Labels helfen beim Wiederfinden im Storage und erscheinen in der JSON-Antwort.</p>
        </div>
      </div>
      <div class="md:col-span-2 flex flex-wrap items-center gap-4">
        <label class="inline-flex items-center gap-2 text-sm text-slate-700" for="crawler-shadow">
          <input
            type="checkbox"
            id="crawler-shadow"
            class="h-4 w-4 rounded border-slate-300 text-slate-900 focus:ring-slate-500"
          />
          Shadow Mode (Upsert überspringen)
        </label>
        <label class="inline-flex items-center gap-2 text-sm text-slate-700" for="crawler-dry-run">
          <input
            type="checkbox"
            id="crawler-dry-run"
            class="h-4 w-4 rounded border-slate-300 text-slate-900 focus:ring-slate-500"
          />
          Dry-Run (nur Simulation)
        </label>
      </div>
      <div class="md:col-span-2 flex flex-wrap items-center gap-3">
        <button
          class="inline-flex items-center rounded-md bg-slate-900 px-4 py-2 text-sm font-medium text-white shadow-sm transition hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-offset-2"
          type="submit"
        >
          Crawl starten
        </button>
        <button
          class="inline-flex items-center rounded-md border border-slate-300 px-4 py-2 text-sm font-medium text-slate-700 shadow-sm transition hover:bg-slate-100 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-offset-2 disabled:opacity-50"
          type="button"
          id="crawler-approve"
          disabled
        >
          Review freigeben
        </button>
        <button
          class="inline-flex items-center rounded-md border border-slate-300 px-4 py-2 text-sm font-medium text-slate-700 shadow-sm transition hover:bg-slate-100 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-offset-2 disabled:opacity-50"
          type="button"
          id="crawler-reject"
          disabled
        >
          Review ablehnen
        </button>
        <span class="text-xs text-slate-500" id="crawler-review-indicator">Review offen: –</span>
      </div>
    </form>

    <div class="space-y-3">
      <div
        id="crawler-error"
        class="hidden rounded-md border border-red-200 bg-red-50 p-3 text-sm text-red-700"
      ></div>
      <div class="grid gap-6 lg:grid-cols-2">
        <div class="space-y-4">
          <div class="space-y-1">
            <h3 class="text-sm font-semibold uppercase tracking-wide text-slate-600">Status</h3>
            <dl class="space-y-1 text-sm text-slate-700">
              <div class="flex items-center justify-between gap-3">
                <dt class="font-medium text-slate-600">Decision</dt>
                <dd><code class="rounded bg-slate-100 px-2 py-1 text-xs" id="crawler-decision">–</code></dd>
              </div>
              <div class="flex items-center justify-between gap-3">
                <dt class="font-medium text-slate-600">Manual Review</dt>
                <dd><code class="rounded bg-slate-100 px-2 py-1 text-xs" id="crawler-manual-status">–</code></dd>
              </div>
              <div class="flex items-center justify-between gap-3">
                <dt class="font-medium text-slate-600">Shadow Mode</dt>
                <dd><code class="rounded bg-slate-100 px-2 py-1 text-xs" id="crawler-shadow-state">–</code></dd>
              </div>
              <div class="flex items-center justify-between gap-3">
                <dt class="font-medium text-slate-600">Live Fetch genutzt</dt>
                <dd><code class="rounded bg-slate-100 px-2 py-1 text-xs" id="crawler-fetch-used">–</code></dd>
              </div>
              <div class="flex items-center justify-between gap-3">
                <dt class="font-medium text-slate-600">HTTP Status</dt>
                <dd><code class="rounded bg-slate-100 px-2 py-1 text-xs" id="crawler-http-status">–</code></dd>
              </div>
              <div class="flex items-center justify-between gap-3">
                <dt class="font-medium text-slate-600">Fetched Bytes</dt>
                <dd><code class="rounded bg-slate-100 px-2 py-1 text-xs" id="crawler-fetched-bytes">–</code></dd>
              </div>
              <div class="flex items-center justify-between gap-3">
                <dt class="font-medium text-slate-600">Snapshot requested</dt>
                <dd><code class="rounded bg-slate-100 px-2 py-1 text-xs" id="crawler-snapshot-requested">–</code></dd>
              </div>
              <div class="flex items-center justify-between gap-3">
                <dt class="font-medium text-slate-600">Snapshot Label</dt>
                <dd><code class="rounded bg-slate-100 px-2 py-1 text-xs" id="crawler-snapshot-label-display">–</code></dd>
              </div>
              <div class="flex items-center justify-between gap-3">
                <dt class="font-medium text-slate-600">Snapshot Path</dt>
                <dd><code class="rounded bg-slate-100 px-2 py-1 text-xs" id="crawler-snapshot-path">–</code></dd>
              </div>
              <div class="flex items-center justify-between gap-3">
                <dt class="font-medium text-slate-600">Snapshot SHA256</dt>
                <dd><code class="rounded bg-slate-100 px-2 py-1 text-xs" id="crawler-snapshot-sha">–</code></dd>
              </div>
              <div class="flex items-center justify-between gap-3">
                <dt class="font-medium text-slate-600">Graph Run</dt>
                <dd><code class="rounded bg-slate-100 px-2 py-1 text-xs" id="crawler-run-id">–</code></dd>
              </div>
            </dl>
            <div class="space-y-2">
              <h4 class="text-xs font-semibold uppercase tracking-wide text-slate-500">Origin Outcomes</h4>
              <div id="crawler-origin-outcomes" class="space-y-2 text-xs text-slate-600">
                <p class="text-xs text-slate-500">Noch keine Ausführung gestartet.</p>
              </div>
            </div>
          </div>
          <div class="space-y-2">
            <h3 class="text-sm font-semibold uppercase tracking-wide text-slate-600">Transitions</h3>
            <div id="crawler-transitions" class="space-y-3 text-sm text-slate-700">
              <p class="text-sm text-slate-500">Noch keine Ausführung gestartet.</p>
            </div>
          </div>
        </div>
        <div class="space-y-2">
          <div class="flex items-center justify-between">
            <h3 class="text-sm font-semibold uppercase tracking-wide text-slate-600">Rohdaten</h3>
            <button
              type="button"
              id="crawler-copy"
              class="inline-flex items-center rounded-md border border-slate-300 px-3 py-1 text-xs font-medium text-slate-700 transition hover:bg-slate-100 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-offset-2"
            >
              Copy JSON
            </button>
          </div>
          <pre class="max-h-80 overflow-auto rounded-lg bg-slate-950 p-4 text-xs text-slate-100" id="crawler-json"></pre>
          <p class="text-xs text-slate-500">Smoke Hinweis: Nutze „Copy JSON“, um Fetch- und Snapshot-Felder manuell zu validieren. Optisches QA via Browser-Stack durchführen, sobald verfügbar.</p>
        </div>
      </div>
    </div>
  </section>



  <section class="rounded-lg border border-slate-200 bg-white p-6 shadow-sm space-y-6">
    <div class="space-y-2">
      <h2 class="text-xl font-semibold text-slate-900">Upload Document</h2>
      <p class="text-sm text-slate-600">
        Lade eine Datei hoch, registriere sie im Dokumentenspeicher und starte automatisch eine Ingestion.
        Der Resolver empfiehlt das Profil <code class="rounded bg-slate-100 px-1 py-0.5 text-xs">{{ resolver_profile_hint|default:"–" }}</code>
        und weist Uploads der Collection <code class="rounded bg-slate-100 px-1 py-0.5 text-xs" data-collection-display>{{ resolver_collection_hint|default:"–" }}</code> zu.
        Die Antwort enthält weiterhin die <code class="rounded bg-slate-100 px-1 py-0.5 text-xs">document_id</code>
        sowie den zugehörigen <code class="rounded bg-slate-100 px-1 py-0.5 text-xs">ingestion_run_id</code>.
      </p>
    </div>

    <div class="rounded-md border border-slate-200 bg-slate-50 p-4 text-sm text-slate-600 space-y-2">
      <div class="flex flex-wrap items-center justify-between gap-2">
        <span class="font-medium text-slate-700">Aktive Collection (Resolver)</span>
        <code class="rounded bg-slate-200 px-2 py-0.5 text-xs font-mono" data-collection-display>{{ resolver_collection_hint|default:"–" }}</code>
      </div>
      <p class="text-xs text-slate-500">
        Uploads und Ingestion verwenden diese Collection. Passe das Scope über das Feld
        „Collection“ im Query-Formular an; ohne Auswahl wird der Vorgang abgebrochen.
      </p>
    </div>

    <div class="space-y-1">
      <label class="text-sm font-medium text-slate-700" for="upload-collection">Collection</label>
      <input
        class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
        id="upload-collection"
        type="search"
        list="query-collection-options"
        placeholder="z. B. 123e4567-e89b-12d3-a456-426614174000"
        autocomplete="off"
      />
      <p class="text-xs text-slate-500">Tipp: Dieses Feld steuert auch Uploads. Alternativ das Collection-Feld im Query‑Abschnitt verwenden.</p>
    </div>

    <form id="upload-form" class="space-y-4">
      <div class="space-y-1">
        <label class="block text-sm font-medium text-slate-700" for="upload-file">Datei</label>
        <input
          class="block w-full rounded-md border border-slate-300 bg-white px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
          id="upload-file"
          name="file"
          type="file"
          required
        />
      </div>
      <div class="space-y-1">
        <div class="flex items-center justify-between gap-2">
          <label class="text-sm font-medium text-slate-700" for="upload-metadata">Metadata (optional)</label>
          <span class="text-xs text-slate-500">JSON-Struktur, z.&nbsp;B. {"case": "abc"}</span>
        </div>
        <textarea
          class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
          id="upload-metadata"
          name="metadata"
          rows="4"
        ></textarea>
      </div>
      <button
        class="inline-flex items-center rounded-md bg-slate-900 px-4 py-2 text-sm font-medium text-white shadow-sm transition hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-offset-2"
        type="submit"
      >
        Upload starten
      </button>
    </form>
    <div class="space-y-2">
      <h3 class="text-sm font-semibold uppercase tracking-wide text-slate-600">Upload Response</h3>
      <pre class="max-h-64 overflow-auto rounded-lg bg-slate-950 p-4 text-xs text-slate-100" id="upload-response"></pre>
    </div>
  </section>

  <section class="rounded-lg border border-slate-200 bg-white p-6 shadow-sm space-y-6">
    <div class="space-y-2">
      <h2 class="text-xl font-semibold text-slate-900">Ingestion Control</h2>
      <p class="text-sm text-slate-600">
        Steuere den Ingestion-Workflow Schritt für Schritt: Starte Runs für bestehende Dokumente und überwache den Status
        des letzten Durchlaufs im aktuellen Tenant- und Case-Kontext. Alle Aktionen verwenden die aktive Collection
        <code class="rounded bg-slate-100 px-1 py-0.5 text-xs" data-collection-display>{{ resolver_collection_hint|default:"–" }}</code>.
      </p>
    </div>

    <div class="grid gap-8 lg:grid-cols-2">
      <div class="space-y-4">
        <div class="space-y-1">
          <h3 class="text-lg font-semibold text-slate-900">Ingestion Run starten</h3>
          <p class="text-sm text-slate-600">
            Übermittle eine oder mehrere <code class="rounded bg-slate-100 px-1 py-0.5 text-xs">document_id</code>-Werte (Komma oder Zeilenumbruch)
            und wähle das gewünschte Embedding-Profil.
          </p>
        </div>
        <div class="rounded-md border border-slate-200 bg-slate-50 p-3 text-xs text-slate-600">
          <p>
            Aktuelle Collection: <code class="rounded bg-slate-200 px-1 py-0.5 text-xs font-mono" data-collection-display>{{ resolver_collection_hint|default:"–" }}</code>.
            Legacy-Parameter <code class="rounded bg-slate-100 px-1 py-0.5 text-xs">doc_class</code> aus URLs werden – sofern die
            Collection-Routing-Flag aktiv ist – automatisch als Collection übernommen.
          </p>
        </div>
        <form id="ingestion-form" class="space-y-4">
          <div class="space-y-1">
            <label class="block text-sm font-medium text-slate-700" for="ingestion-document-ids">Document IDs</label>
            <textarea
              class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
              id="ingestion-document-ids"
              name="document_ids"
              rows="3"
              placeholder="doc-123, doc-456"
              required
            ></textarea>
          </div>
          <div class="space-y-1">
            <label class="block text-sm font-medium text-slate-700" for="ingestion-profile">Embedding Profile</label>
            <select
              class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
              id="ingestion-profile"
              name="embedding_profile"
            >
              <option value="{{ default_embedding_profile }}">{{ default_embedding_profile }}</option>
              <option value="demo">demo</option>
            </select>
          </div>
          <button
            class="inline-flex items-center rounded-md bg-slate-900 px-4 py-2 text-sm font-medium text-white shadow-sm transition hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-offset-2"
            type="submit"
          >
            Ingestion starten
          </button>
        </form>
        <div class="space-y-2">
          <h4 class="text-sm font-semibold uppercase tracking-wide text-slate-600">Ingestion Response</h4>
          <pre class="max-h-56 overflow-auto rounded-lg bg-slate-950 p-4 text-xs text-slate-100" id="ingestion-response"></pre>
        </div>
      </div>

      <div class="space-y-4">
        <div class="space-y-1">
          <h3 class="text-lg font-semibold text-slate-900">Ingestion Status</h3>
          <p class="text-sm text-slate-600">
            Lies den Status des letzten Ingestion-Runs aus. Der aktuell bekannte Run wird hier angezeigt und kann über
            den Button aktualisiert werden.
          </p>
        </div>
        <div class="rounded-md border border-dashed border-slate-300 bg-slate-50 p-4 text-sm text-slate-600">
          <p>
            Letzter Run: <code class="rounded bg-slate-200 px-1 py-0.5 text-xs" id="last-run-id">–</code>
          </p>
        </div>
        <div class="flex items-center gap-3">
          <button
            class="inline-flex items-center rounded-md bg-slate-900 px-4 py-2 text-sm font-medium text-white shadow-sm transition hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-offset-2"
            type="button"
            id="status-refresh"
          >
            Status aktualisieren
          </button>
          <span class="text-xs text-slate-500">Antwort wird unten angezeigt.</span>
        </div>
        <div class="space-y-2">
          <h4 class="text-sm font-semibold uppercase tracking-wide text-slate-600">Status Response</h4>
          <pre class="max-h-56 overflow-auto rounded-lg bg-slate-950 p-4 text-xs text-slate-100" id="status-response"></pre>
        </div>
      </div>
    </div>
  </section>

  <section class="rounded-lg border border-slate-200 bg-white p-6 shadow-sm">
    <div class="space-y-2">
      <h2 class="text-xl font-semibold text-slate-900">Query</h2>
      <p class="text-sm text-slate-600">
        Führe Queries gegen den Wissensspeicher aus. Über optionale Felder kannst du Routing und Hybrid-Search Feintuning testen.
      </p>
    </div>
    <form id="query-form" class="mt-6 grid gap-6 md:grid-cols-2">
      <div class="md:col-span-2 space-y-1">
        <div class="flex items-center justify-between gap-2">
          <label class="text-sm font-medium text-slate-700" for="query-text">Query</label>
          <span class="text-xs text-slate-500">Wird zusätzlich als <code>question</code> gesendet.</span>
        </div>
        <textarea
          class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
          id="query-text"
          name="query"
          rows="3"
          required
        ></textarea>
      </div>
      <div class="space-y-1">
        <label class="text-sm font-medium text-slate-700" for="query-process">Process</label>
        <input
          class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
          id="query-process"
          name="process"
          type="text"
          placeholder="z. B. classification"
        />
        <p class="text-xs text-slate-500">Optional: Erzwingt einen konkreten Prozess-Flow.</p>
      </div>
      <div class="space-y-1">
        <label class="text-sm font-medium text-slate-700" for="query-collection">Collection</label>
        <input
          class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
          id="query-collection"
          name="collection_id"
          type="search"
          list="query-collection-options"
          placeholder="z. B. support-faq"
          autocomplete="off"
        />
        <p class="text-xs text-slate-500">Hinweis: Erwartet wird eine UUID (8-4-4-4-12); das Feld kann leer bleiben.</p>
        <datalist id="query-collection-options">
          {% for option in collection_options %}
          <option value="{{ option }}"></option>
          {% endfor %}
        </datalist>
        <p class="text-xs text-slate-500">
          Wähle die Collection für Uploads, Ingestion und Queries. Lässt du das Feld frei, werden Queries ohne expliziten
          Collection-Filter gesendet. Legacy-Parameter <code>doc_class</code> aus URLs werden bei aktivem Collection-Routing
          automatisch als Collection verwendet.
        </p>
      </div>
      <div class="space-y-1">
        <label class="text-sm font-medium text-slate-700" for="query-visibility">Visibility</label>
        <select
          class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
          id="query-visibility"
          name="visibility"
        >
          <option value="">Default</option>
          <option value="active">active</option>
          <option value="all">all</option>
          <option value="deleted">deleted</option>
        </select>
        <p class="text-xs text-slate-500">Steuert, welche Dokument-Zustände durchsucht werden.</p>
      </div>
      <fieldset class="md:col-span-2 space-y-4 rounded-md border border-dashed border-slate-300 p-4">
        <legend class="px-1 text-sm font-semibold uppercase tracking-wide text-slate-600">Hybrid Parameter</legend>
        <p class="text-xs text-slate-500">
          Mit diesen Werten kannst du die Balance zwischen Vektor- und Lexikal-Suche steuern. Leere Felder werden nicht gesendet.
        </p>
        <div class="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
          <div class="space-y-1">
            <label class="text-sm font-medium text-slate-700" for="hybrid-alpha">alpha</label>
            <input
              class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
              id="hybrid-alpha"
              name="alpha"
              type="number"
              step="0.01"
              min="0"
              max="1"
              placeholder="0–1"
            />
            <p class="text-xs text-slate-500">Mischverhältnis Hybrid-Suche (0 = rein lexikalisch, 1 = rein vektorbasiert).</p>
          </div>
          <div class="space-y-1">
            <label class="text-sm font-medium text-slate-700" for="hybrid-min-sim">min_sim</label>
            <input
              class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
              id="hybrid-min-sim"
              name="min_sim"
              type="number"
              step="0.01"
              min="0"
              max="1"
              placeholder="z. B. 0.35"
            />
            <p class="text-xs text-slate-500">Mindestsimilarität für Treffer im Vektorraum.</p>
          </div>
          <div class="space-y-1">
            <label class="text-sm font-medium text-slate-700" for="hybrid-top-k">top_k</label>
            <input
              class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
              id="hybrid-top-k"
              name="top_k"
              type="number"
              min="1"
              placeholder="Standard 5"
            />
            <p class="text-xs text-slate-500">Anzahl der kombinierten Kandidaten aus beiden Retrieval-Wege.</p>
          </div>
          <div class="space-y-1">
            <label class="text-sm font-medium text-slate-700" for="hybrid-vec-limit">vec_limit</label>
            <input
              class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
              id="hybrid-vec-limit"
              name="vec_limit"
              type="number"
              min="1"
              placeholder="Vektor-Kandidaten"
            />
            <p class="text-xs text-slate-500">Maximale Treffer aus dem Vektorindex.</p>
          </div>
          <div class="space-y-1">
            <label class="text-sm font-medium text-slate-700" for="hybrid-lex-limit">lex_limit</label>
            <input
              class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
              id="hybrid-lex-limit"
              name="lex_limit"
              type="number"
              min="1"
              placeholder="Lexikal-Kandidaten"
            />
            <p class="text-xs text-slate-500">Maximale Treffer aus der BM25/Trigram Suche.</p>
          </div>
          <div class="space-y-1">
            <label class="text-sm font-medium text-slate-700" for="hybrid-max-candidates">max_candidates</label>
            <input
              class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
              id="hybrid-max-candidates"
              name="max_candidates"
              type="number"
              min="1"
              placeholder="Gesamtkandidaten"
            />
            <p class="text-xs text-slate-500">Deckel für gemergte Treffer vor Re-Ranking.</p>
          </div>
          <div class="space-y-1">
            <label class="text-sm font-medium text-slate-700" for="hybrid-trgm-limit">trgm_limit</label>
            <input
              class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
              id="hybrid-trgm-limit"
              name="trgm_limit"
              type="number"
              step="0.01"
              min="0"
              max="1"
              placeholder="0–1"
            />
            <p class="text-xs text-slate-500">Grenze für trigram-basierte Recall-Erweiterung.</p>
          </div>
        </div>
      </fieldset>
      <div class="md:col-span-2">
        <button
          id="query-submit"
          class="inline-flex items-center rounded-md bg-slate-900 px-4 py-2 text-sm font-medium text-white shadow-sm transition hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-offset-2"
          type="submit"
        >
          Query starten
        </button>
      </div>
    </form>
    <div class="mt-6 space-y-6" id="rag-output">
      <div id="rag-error" class="hidden rounded-md border border-red-200 bg-red-50 p-3 text-sm text-red-700"></div>

      <section class="space-y-3">
        <div class="flex items-center justify-between">
          <h3 class="text-sm font-semibold uppercase tracking-wide text-slate-600">Answer</h3>
          <button
            type="button"
            id="rag-answer-copy"
            class="inline-flex items-center rounded-md border border-slate-300 px-3 py-1 text-xs font-medium text-slate-700 transition hover:bg-slate-100 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-offset-2"
          >
            Copy
          </button>
        </div>
        <div
          id="rag-answer"
          class="whitespace-pre-wrap rounded-md border border-slate-200 bg-slate-50 p-4 text-sm text-slate-900"
        >
          –
        </div>
      </section>

      <section class="space-y-2">
        <h3 class="text-sm font-semibold uppercase tracking-wide text-slate-600">Prompt Version</h3>
        <code
          id="rag-prompt-version"
          class="inline-block rounded bg-slate-900 px-2 py-1 text-xs font-medium text-white"
        >
          –
        </code>
      </section>

      <section class="space-y-3">
        <h3 class="text-sm font-semibold uppercase tracking-wide text-slate-600">Retrieval Diagnostics</h3>
        <div class="overflow-x-auto">
          <table id="rag-diagnostics" class="min-w-full divide-y divide-slate-200 text-sm">
            <tbody class="divide-y divide-slate-200">
              <tr data-field="alpha">
                <th class="whitespace-nowrap bg-slate-50 px-3 py-2 text-left font-medium text-slate-600">alpha</th>
                <td class="px-3 py-2 font-mono text-slate-900">–</td>
              </tr>
              <tr data-field="min_sim">
                <th class="whitespace-nowrap bg-slate-50 px-3 py-2 text-left font-medium text-slate-600">min_sim</th>
                <td class="px-3 py-2 font-mono text-slate-900">–</td>
              </tr>
              <tr data-field="top_k_effective">
                <th class="whitespace-nowrap bg-slate-50 px-3 py-2 text-left font-medium text-slate-600">top_k_effective</th>
                <td class="px-3 py-2 font-mono text-slate-900">–</td>
              </tr>
              <tr data-field="matches_returned">
                <th class="whitespace-nowrap bg-slate-50 px-3 py-2 text-left font-medium text-slate-600">matches_returned</th>
                <td class="px-3 py-2 font-mono text-slate-900">–</td>
              </tr>
              <tr data-field="max_candidates_effective">
                <th class="whitespace-nowrap bg-slate-50 px-3 py-2 text-left font-medium text-slate-600">max_candidates_effective</th>
                <td class="px-3 py-2 font-mono text-slate-900">–</td>
              </tr>
              <tr data-field="vector_candidates">
                <th class="whitespace-nowrap bg-slate-50 px-3 py-2 text-left font-medium text-slate-600">vector_candidates</th>
                <td class="px-3 py-2 font-mono text-slate-900">–</td>
              </tr>
              <tr data-field="lexical_candidates">
                <th class="whitespace-nowrap bg-slate-50 px-3 py-2 text-left font-medium text-slate-600">lexical_candidates</th>
                <td class="px-3 py-2 font-mono text-slate-900">–</td>
              </tr>
              <tr data-field="deleted_matches_blocked">
                <th class="whitespace-nowrap bg-slate-50 px-3 py-2 text-left font-medium text-slate-600">deleted_matches_blocked</th>
                <td class="px-3 py-2 font-mono text-slate-900">–</td>
              </tr>
              <tr data-field="visibility_effective">
                <th class="whitespace-nowrap bg-slate-50 px-3 py-2 text-left font-medium text-slate-600">visibility_effective</th>
                <td class="px-3 py-2 font-mono text-slate-900">–</td>
              </tr>
              <tr data-field="took_ms">
                <th class="whitespace-nowrap bg-slate-50 px-3 py-2 text-left font-medium text-slate-600">took_ms</th>
                <td class="px-3 py-2 font-mono text-slate-900">–</td>
              </tr>
              <tr data-field="routing.profile">
                <th class="whitespace-nowrap bg-slate-50 px-3 py-2 text-left font-medium text-slate-600">routing.profile</th>
                <td class="px-3 py-2 font-mono text-slate-900">–</td>
              </tr>
              <tr data-field="routing.vector_space_id">
                <th class="whitespace-nowrap bg-slate-50 px-3 py-2 text-left font-medium text-slate-600">routing.vector_space_id</th>
                <td class="px-3 py-2 font-mono text-slate-900">–</td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>

      <section class="space-y-3">
        <h3 class="text-sm font-semibold uppercase tracking-wide text-slate-600">Snippets</h3>
        <div id="rag-snippets" class="space-y-3">
          <p class="text-sm text-slate-500">Keine Snippets geladen.</p>
        </div>
      </section>

      <section class="space-y-2">
        <div class="flex flex-wrap items-center gap-3">
          <label class="inline-flex items-center gap-2 text-sm text-slate-700" for="rag-raw-toggle">
            <input
              type="checkbox"
              id="rag-raw-toggle"
              class="h-4 w-4 rounded border-slate-300 text-slate-900 focus:ring-slate-500"
            />
            Raw JSON anzeigen
          </label>
          <button
            type="button"
            id="rag-raw-copy"
            class="inline-flex items-center rounded-md border border-slate-300 px-3 py-1 text-xs font-medium text-slate-700 transition hover:bg-slate-100 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-offset-2"
          >
            Copy JSON
          </button>
        </div>
        <pre class="hidden max-h-96 overflow-auto rounded-lg bg-slate-950 p-4 text-xs text-slate-100" id="rag-raw"></pre>
      </section>
    </div>
  </section>
</div>

<script>
  (function () {
    const derivedTenantId = "{{ tenant_id|escapejs }}";
    const derivedTenantSchema = "{{ tenant_schema|escapejs }}";
    const tenantId = derivedTenantId || window.location.hostname || "dev.localhost";
    const tenantSchema =
      derivedTenantSchema ||
      (tenantId && tenantId.includes(".") ? tenantId.split(".", 1)[0] : tenantId) ||
      "dev";
    const defaultEmbeddingProfile = "{{ default_embedding_profile|escapejs }}" || "standard";
    const allowDocClassAlias = {{ collection_alias_enabled|yesno:'true,false' }};
    const resolverProfileHint = "{{ resolver_profile_hint|default_if_none:''|escapejs }}";
    const resolverCollectionHint = "{{ resolver_collection_hint|default_if_none:''|escapejs }}";
    const crawlerRunnerUrl = "{{ crawler_runner_url|escapejs }}";
    const crawlerDefaultWorkflow = "{{ crawler_default_workflow_id|default_if_none:''|escapejs }}";
    const crawlerShadowDefault = {{ crawler_shadow_default|yesno:'true,false' }};
    const crawlerDryRunDefault = {{ crawler_dry_run_default|yesno:'true,false' }};
    const support = window.RagToolsSupport || {};
    const normalizeCollectionInput =
      typeof support.normalizeCollectionInput === 'function'
        ? support.normalizeCollectionInput
        : function (value) {
            if (typeof value !== 'string') {
              return '';
            }
            const trimmed = value.trim();
            return trimmed || '';
          };
    const resolveEffectiveCollectionId =
      typeof support.resolveEffectiveCollectionId === 'function'
        ? support.resolveEffectiveCollectionId
        : function (options) {
            const opts = options || {};
            const direct = normalizeCollectionInput(opts.collectionInput);
            if (direct) {
              return direct;
            }
            if (!opts.allowLegacy) {
              return '';
            }
            return normalizeCollectionInput(opts.legacyDocClass);
          };
    const formatCollectionDisplay =
      typeof support.formatCollectionDisplay === 'function'
        ? support.formatCollectionDisplay
        : function (value) {
            const normalized = normalizeCollectionInput(value);
            return normalized || '–';
          };
    const sanitizeKnownCollections =
      typeof support.sanitizeKnownCollections === 'function'
        ? support.sanitizeKnownCollections
        : function (values) {
            if (!Array.isArray(values)) {
              return [];
            }
            const seen = new Set();
            return values.reduce(function (acc, entry) {
              const normalized = normalizeCollectionInput(entry);
              if (!normalized || seen.has(normalized)) {
                return acc;
              }
              seen.add(normalized);
              acc.push(normalized);
              return acc;
            }, []);
          };
    const baseIsKnownCollection =
      typeof support.isKnownCollection === 'function'
        ? support.isKnownCollection
        : function (value, list) {
          if (!Array.isArray(list) || list.length === 0) {
            return false;
          }
          const normalizedValue = normalizeCollectionInput(value);
          if (!normalizedValue) {
            return false;
          }
          return list.includes(normalizedValue);
        };

    const buildCrawlerPayload =
      typeof support.buildCrawlerPayload === 'function'
        ? support.buildCrawlerPayload
        : function (options) {
            const opts = options || {};
            const payload = {};
            if (opts.workflowId) {
              payload.workflow_id = String(opts.workflowId).trim();
            }
            if (opts.originUrl) {
              payload.origin_url = String(opts.originUrl).trim();
            }
            if (opts.documentId) {
              payload.document_id = String(opts.documentId).trim();
            }
            if (opts.title) {
              payload.title = String(opts.title).trim();
            }
            if (opts.language) {
              payload.language = String(opts.language).trim();
            }
            if (opts.contentType) {
              payload.content_type = String(opts.contentType).trim();
            }
            if (opts.content) {
              payload.content = String(opts.content);
            }
            if (opts.provider) {
              payload.provider = String(opts.provider).trim();
            }
            if (opts.tags) {
              if (Array.isArray(opts.tags)) {
                payload.tags = opts.tags.filter(Boolean);
              } else if (typeof opts.tags === 'string') {
                payload.tags = opts.tags
                  .split(',')
                  .map(function (entry) {
                    return entry.trim();
                  })
                  .filter(Boolean);
              }
            }
            if (opts.maxDocumentBytes !== undefined && opts.maxDocumentBytes !== null && opts.maxDocumentBytes !== '') {
              const parsed = Number(opts.maxDocumentBytes);
              if (!Number.isNaN(parsed) && parsed >= 0) {
                payload.max_document_bytes = Math.floor(parsed);
              }
            }
            if (opts.shadowMode != null) {
              payload.shadow_mode = Boolean(opts.shadowMode);
            }
            if (opts.dryRun != null) {
              payload.dry_run = Boolean(opts.dryRun);
            }
            if (opts.manualReview) {
              payload.manual_review = String(opts.manualReview).trim();
            }
            if (opts.forceRetire != null) {
              payload.force_retire = Boolean(opts.forceRetire);
            }
            if (opts.recomputeDelta != null) {
              payload.recompute_delta = Boolean(opts.recomputeDelta);
            }
            return payload;
          };

    const normalizeCrawlerManualReview =
      typeof support.normalizeCrawlerManualReview === 'function'
        ? support.normalizeCrawlerManualReview
        : function (value) {
            if (typeof value !== 'string') {
              return null;
            }
            const lowered = value.trim().toLowerCase();
            if (!lowered) {
              return null;
            }
            if (['required', 'approved', 'rejected'].includes(lowered)) {
              return lowered;
            }
            return null;
          };


    // Simple UUID v4-like check (case-insensitive)
    function isUuidLike(value) {
      if (!value || typeof value !== 'string') return false;
      const text = value.trim();
      return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(text);
    }

    const staticHeaders = {
      'X-Tenant-ID': tenantId,
      'X-Tenant-Schema': tenantSchema,
      'X-User-ID': 'local',
      'X-Case-ID': 'local'
    };
    const searchParams = new URLSearchParams(window.location.search || '');
    const initialCollectionParam = searchParams.get('collection_id');
    const legacyDocClassParam = allowDocClassAlias ? searchParams.get('doc_class') : null;
    const resolverCollectionHintNormalized = normalizeCollectionInput(resolverCollectionHint);
    const collectionOptions = Array.from(
      document.querySelectorAll('#query-collection-options option')
    ).map(function (option) {
      return option.value;
    });
    const knownCollections = sanitizeKnownCollections(collectionOptions);
    const isKnownCollection = function (value) {
      return baseIsKnownCollection(value, knownCollections);
    };

    let currentCollectionId = resolveEffectiveCollectionId({
      collectionInput: initialCollectionParam,
      legacyDocClass: legacyDocClassParam,
      allowLegacy: allowDocClassAlias,
    });
    if (!currentCollectionId) {
      currentCollectionId = resolverCollectionHintNormalized;
    }

    function updateCollectionDisplays(value) {
      const formatted = formatCollectionDisplay(value);
      const targets = document.querySelectorAll('[data-collection-display]');
      targets.forEach(function (element) {
        element.textContent = formatted;
        if (value && isKnownCollection(value)) {
          element.setAttribute('data-known', 'true');
        } else {
          element.setAttribute('data-known', 'false');
        }
      });
    }

    function buildHeaders(additional) {
      const headers = { ...staticHeaders };
      if (additional && typeof additional === 'object') {
        Object.keys(additional).forEach(function (key) {
          headers[key] = additional[key];
        });
      }
      if (currentCollectionId && isUuidLike(currentCollectionId)) {
        headers['X-Collection-ID'] = currentCollectionId;
      }
      return headers;
    }

    function determineCollection(rawValue, options) {
      const opts = options || {};
      const resolved = resolveEffectiveCollectionId({
        collectionInput: rawValue,
        legacyDocClass: legacyDocClassParam,
        allowLegacy: allowDocClassAlias,
      });
      if (resolved) {
        return resolved;
      }
      if (opts.allowResolverFallback && resolverCollectionHintNormalized) {
        return resolverCollectionHintNormalized;
      }
      return '';
    }

    function requireCollection(scope) {
      const opts = scope || {};
      const rawValue =
        opts.rawValue !== undefined
          ? opts.rawValue
          : collectionInput && collectionInput instanceof HTMLInputElement
          ? collectionInput.value
          : currentCollectionId;
      const resolved = determineCollection(rawValue, {
        allowResolverFallback: opts.allowResolverFallback !== false,
      });
      if (!resolved) {
        currentCollectionId = '';
        updateCollectionDisplays('');
        return null;
      }
      currentCollectionId = resolved;
      if (collectionInput && collectionInput instanceof HTMLInputElement) {
        collectionInput.value = currentCollectionId;
      }
      if (uploadCollectionInput && uploadCollectionInput instanceof HTMLInputElement) {
        uploadCollectionInput.value = currentCollectionId;
      }
      if (crawlerCollectionInput && crawlerCollectionInput instanceof HTMLInputElement) {
        crawlerCollectionInput.value = currentCollectionId;
      }
      updateCollectionDisplays(currentCollectionId);
      return currentCollectionId;
    }

    const collectionInput = document.getElementById('query-collection');
    const uploadCollectionInput = document.getElementById('upload-collection');
    const crawlerCollectionInput = document.getElementById('crawler-collection');
    updateCollectionDisplays(currentCollectionId);
    if (collectionInput && collectionInput instanceof HTMLInputElement) {
      if (currentCollectionId) {
        collectionInput.value = currentCollectionId;
      }
      collectionInput.addEventListener('change', function (event) {
        const resolved = requireCollection({ rawValue: event.target.value, allowResolverFallback: false });
        if (!resolved) {
          updateCollectionDisplays('');
        }
      });
      collectionInput.addEventListener('blur', function (event) {
        const resolved = requireCollection({ rawValue: event.target.value, allowResolverFallback: false });
        if (!resolved) {
          updateCollectionDisplays('');
        }
      });
    }
    if (crawlerCollectionInput && crawlerCollectionInput instanceof HTMLInputElement) {
      if (currentCollectionId) {
        crawlerCollectionInput.value = currentCollectionId;
      }
      const syncCrawlerCollection = function (event) {
        const resolved = requireCollection({ rawValue: event.target.value, allowResolverFallback: false });
        if (!resolved) {
          updateCollectionDisplays('');
        }
      };
      crawlerCollectionInput.addEventListener('change', syncCrawlerCollection);
      crawlerCollectionInput.addEventListener('blur', syncCrawlerCollection);
    }
    if (uploadCollectionInput && uploadCollectionInput instanceof HTMLInputElement) {
      if (currentCollectionId) {
        uploadCollectionInput.value = currentCollectionId;
      }
      uploadCollectionInput.addEventListener('change', function (event) {
        const resolved = requireCollection({ rawValue: event.target.value, allowResolverFallback: false });
        if (!resolved) {
          updateCollectionDisplays('');
        }
      });
      uploadCollectionInput.addEventListener('blur', function (event) {
        const resolved = requireCollection({ rawValue: event.target.value, allowResolverFallback: false });
        if (!resolved) {
          updateCollectionDisplays('');
        }
      });
    }

    let lastRunId = null;

    function getCsrfToken() {
      const match = document.cookie.match(/(?:^|; )csrftoken=([^;]+)/);
      return match ? decodeURIComponent(match[1]) : null;
    }

    function renderJson(target, value) {
      const element = document.getElementById(target);
      if (!element) return;
      element.textContent = value;
    }

    function prettyPrint(target, data) {
      renderJson(target, JSON.stringify(data, null, 2));
    }

    function updateLastRunId(runId) {
      if (!runId) {
        return;
      }
      lastRunId = runId;
      const display = document.getElementById('last-run-id');
      if (display) {
        display.textContent = runId;
      }
    }

    async function parseJsonOrText(res) {
      const text = await res.text();
      try {
        return [res, JSON.parse(text)];
      } catch (err) {
        return [res, { __raw: text }];
      }
    }

    function showError(message) {
      const element = document.getElementById('rag-error');
      if (!element) {
        return;
      }
      element.textContent = message;
      element.classList.remove('hidden');
    }

    function clearError() {
      const element = document.getElementById('rag-error');
      if (!element) {
        return;
      }
      element.textContent = '';
      element.classList.add('hidden');
    }

    function resetDiagnostics() {
      const rows = document.querySelectorAll('#rag-diagnostics tr');
      rows.forEach(function (row) {
        const valueCell = row.querySelector('td');
        if (valueCell) {
          valueCell.textContent = '–';
        }
      });
    }

    function resetSnippets(message) {
      const container = document.getElementById('rag-snippets');
      if (!container) {
        return;
      }
      container.innerHTML = '';
      const placeholder = document.createElement('p');
      placeholder.className = 'text-sm text-slate-500';
      placeholder.textContent = message || 'Keine Snippets geladen.';
      container.appendChild(placeholder);
    }

    function resetRagView() {
      const answer = document.getElementById('rag-answer');
      if (answer) {
        answer.textContent = '–';
      }
      const prompt = document.getElementById('rag-prompt-version');
      if (prompt) {
        prompt.textContent = '–';
      }
      resetDiagnostics();
      resetSnippets();
      const raw = document.getElementById('rag-raw');
      if (raw) {
        raw.textContent = '';
        const rawToggle = document.getElementById('rag-raw-toggle');
        if (rawToggle && rawToggle instanceof HTMLInputElement) {
          if (rawToggle.checked) {
            raw.classList.remove('hidden');
          } else {
            raw.classList.add('hidden');
          }
        } else {
          raw.classList.add('hidden');
        }
      }
    }

    function setRaw(data) {
      const target = document.getElementById('rag-raw');
      if (!target) {
        return;
      }
      if (data === null || data === undefined) {
        target.textContent = '';
        return;
      }
      target.textContent = JSON.stringify(data, null, 2);
    }

    function fmtFloat(value) {
      if (!Number.isFinite(value)) {
        return '–';
      }
      return Number(value).toFixed(3);
    }

    function fmtNumber(value) {
      if (Number.isFinite(value)) {
        return String(value);
      }
      if (typeof value === 'boolean') {
        return value ? 'true' : 'false';
      }
      return '–';
    }

    function fmtString(value) {
      if (value === null || value === undefined) {
        return '–';
      }
      const stringValue = String(value);
      return stringValue.trim() === '' ? '–' : stringValue;
    }

    function truncate(text, limit) {
      const maxLength = typeof limit === 'number' && limit > 0 ? limit : 280;
      if (typeof text !== 'string') {
        return '';
      }
      if (text.length <= maxLength) {
        return text;
      }
      return text.slice(0, maxLength) + '…';
    }

    function renderRagV2(data) {
      if (!data || typeof data !== 'object') {
        showError('Server liefert kein RAG v2 Schema (Pflichtfelder fehlen).');
        return false;
      }

      const requiredTopLevel = ['answer', 'prompt_version', 'retrieval', 'snippets'];
      for (let i = 0; i < requiredTopLevel.length; i += 1) {
        const key = requiredTopLevel[i];
        if (!(key in data)) {
          showError('Server liefert kein RAG v2 Schema (Pflichtfelder fehlen).');
          return false;
        }
      }

      const retrieval = data.retrieval;
      if (!retrieval || typeof retrieval !== 'object') {
        showError('Server liefert kein RAG v2 Schema (Pflichtfelder fehlen).');
        return false;
      }

      const requiredRetrieval = [
        'alpha',
        'min_sim',
        'top_k_effective',
        'matches_returned',
        'max_candidates_effective',
        'vector_candidates',
        'lexical_candidates',
        'deleted_matches_blocked',
        'visibility_effective',
        'took_ms',
        'routing'
      ];

      for (let i = 0; i < requiredRetrieval.length; i += 1) {
        const key = requiredRetrieval[i];
        if (!(key in retrieval)) {
          showError('Server liefert kein RAG v2 Schema (Pflichtfelder fehlen).');
          return false;
        }
      }

      const routing = retrieval.routing;
      if (!routing || typeof routing !== 'object') {
        showError('Server liefert kein RAG v2 Schema (Pflichtfelder fehlen).');
        return false;
      }

      if (!('profile' in routing) || !('vector_space_id' in routing)) {
        showError('Server liefert kein RAG v2 Schema (Pflichtfelder fehlen).');
        return false;
      }

      if (!Array.isArray(data.snippets)) {
        showError('Server liefert kein RAG v2 Schema (Pflichtfelder fehlen).');
        return false;
      }

      const answer = document.getElementById('rag-answer');
      if (answer) {
        if (typeof data.answer === 'string') {
          answer.textContent = data.answer;
        } else if (data.answer == null) {
          answer.textContent = '–';
        } else {
          answer.textContent = String(data.answer);
        }
      }

      const prompt = document.getElementById('rag-prompt-version');
      if (prompt) {
        if (typeof data.prompt_version === 'string') {
          prompt.textContent = data.prompt_version;
        } else if (data.prompt_version == null) {
          prompt.textContent = '–';
        } else {
          prompt.textContent = String(data.prompt_version);
        }
      }

      const diagnostics = [
        ['alpha', fmtFloat(retrieval.alpha)],
        ['min_sim', fmtFloat(retrieval.min_sim)],
        ['top_k_effective', fmtNumber(retrieval.top_k_effective)],
        ['matches_returned', fmtNumber(retrieval.matches_returned)],
        ['max_candidates_effective', fmtNumber(retrieval.max_candidates_effective)],
        ['vector_candidates', fmtNumber(retrieval.vector_candidates)],
        ['lexical_candidates', fmtNumber(retrieval.lexical_candidates)],
        ['deleted_matches_blocked', fmtNumber(retrieval.deleted_matches_blocked)],
        ['visibility_effective', fmtString(retrieval.visibility_effective)],
        ['took_ms', fmtNumber(retrieval.took_ms)],
        ['routing.profile', fmtString(routing.profile)],
        ['routing.vector_space_id', fmtString(routing.vector_space_id)]
      ];

      diagnostics.forEach(function (entry) {
        const field = entry[0];
        const value = entry[1];
        const row = document.querySelector('#rag-diagnostics tr[data-field="' + field + '"] td');
        if (row) {
          row.textContent = value;
        }
      });

      const snippetContainer = document.getElementById('rag-snippets');
      if (snippetContainer) {
        snippetContainer.innerHTML = '';
        if (Array.isArray(data.snippets) && data.snippets.length) {
          data.snippets.forEach(function (snippet) {
            const card = document.createElement('article');
            card.className = 'space-y-2 rounded-lg border border-slate-200 bg-slate-50 p-4 shadow-sm';

            const header = document.createElement('div');
            header.className = 'flex flex-wrap items-center justify-between gap-2 text-sm text-slate-600';

            const score = document.createElement('span');
            const scoreValue = Number.isFinite(snippet && snippet.score) ? Number(snippet.score).toFixed(3) : '–';
            score.textContent = 'Score: ' + scoreValue;

            const source = document.createElement('span');
            const sourceValue = snippet && typeof snippet.source === 'string' ? snippet.source : '';
            const citationValue = snippet && typeof snippet.citation === 'string' && snippet.citation.trim()
              ? snippet.citation.trim()
              : sourceValue || '–';
            source.textContent = 'Fundstelle: ' + citationValue;

            header.appendChild(score);
            header.appendChild(source);

            const body = document.createElement('div');
            body.className = 'max-h-48 overflow-auto whitespace-pre-wrap text-sm text-slate-700';
            const snippetText = snippet && typeof snippet.text === 'string' ? snippet.text : '';
            body.textContent = truncate(snippetText, 280);

            card.appendChild(header);
            card.appendChild(body);
            snippetContainer.appendChild(card);
          });
        } else {
          const placeholder = document.createElement('p');
          placeholder.className = 'text-sm text-slate-500';
          placeholder.textContent = 'Keine Snippets gefunden.';
          snippetContainer.appendChild(placeholder);
        }
      }

      return true;
    }

    async function copyText(selector) {
      const element = typeof selector === 'string' ? document.querySelector(selector) : selector;
      if (!element) {
        return;
      }
      const value = element.textContent || '';
      if (!value) {
        return;
      }
      if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
        try {
          await navigator.clipboard.writeText(value);
          return;
        } catch (err) {
          // Fallback below
        }
      }

      const textarea = document.createElement('textarea');
      textarea.value = value;
      textarea.setAttribute('readonly', '');
      textarea.style.position = 'absolute';
      textarea.style.left = '-9999px';
      document.body.appendChild(textarea);
      textarea.select();
      try {
        document.execCommand('copy');
      } catch (err) {
        console.warn('Copy failed', err);
      }
      document.body.removeChild(textarea);
    }

    async function copyTextJSON(selector) {
      await copyText(selector);
    }

    const crawlerForm = document.getElementById('crawler-form');
    const crawlerWorkflowInput = document.getElementById('crawler-workflow');
    const crawlerModeSelect = document.getElementById('crawler-mode');
    const crawlerOriginInput = document.getElementById('crawler-origin');
    const crawlerOriginListInput = document.getElementById('crawler-origin-list');
    const crawlerTitleInput = document.getElementById('crawler-title');
    const crawlerLanguageInput = document.getElementById('crawler-language');
    const crawlerProviderInput = document.getElementById('crawler-provider');
    const crawlerTagsInput = document.getElementById('crawler-tags');
    const crawlerContentTypeInput = document.getElementById('crawler-content-type');
    const crawlerMaxBytesInput = document.getElementById('crawler-max-bytes');
    const crawlerFetchToggle = document.getElementById('crawler-fetch');
    const crawlerContentWrapper = document.getElementById('crawler-content-wrapper');
    const crawlerContentInput = document.getElementById('crawler-content');
    const crawlerSnapshotToggle = document.getElementById('crawler-snapshot');
    const crawlerSnapshotLabelWrapper = document.getElementById('crawler-snapshot-label-wrapper');
    const crawlerSnapshotLabelInput = document.getElementById('crawler-snapshot-label');
    const crawlerShadowToggle = document.getElementById('crawler-shadow');
    const crawlerDryRunToggle = document.getElementById('crawler-dry-run');
    const crawlerDecisionDisplay = document.getElementById('crawler-decision');
    const crawlerManualStatus = document.getElementById('crawler-manual-status');
    const crawlerShadowState = document.getElementById('crawler-shadow-state');
    const crawlerRunId = document.getElementById('crawler-run-id');
    const crawlerFetchUsedDisplay = document.getElementById('crawler-fetch-used');
    const crawlerHttpStatusDisplay = document.getElementById('crawler-http-status');
    const crawlerFetchedBytesDisplay = document.getElementById('crawler-fetched-bytes');
    const crawlerSnapshotRequestedDisplay = document.getElementById('crawler-snapshot-requested');
    const crawlerSnapshotLabelDisplay = document.getElementById('crawler-snapshot-label-display');
    const crawlerSnapshotPathDisplay = document.getElementById('crawler-snapshot-path');
    const crawlerSnapshotShaDisplay = document.getElementById('crawler-snapshot-sha');
    const crawlerErrorBox = document.getElementById('crawler-error');
    const crawlerTransitionsContainer = document.getElementById('crawler-transitions');
    const crawlerJson = document.getElementById('crawler-json');
    const crawlerApproveButton = document.getElementById('crawler-approve');
    const crawlerRejectButton = document.getElementById('crawler-reject');
    const crawlerCopyButton = document.getElementById('crawler-copy');
    const crawlerReviewSelect = document.getElementById('crawler-review');
    const crawlerOriginOutcomes = document.getElementById('crawler-origin-outcomes');
    const crawlerReviewIndicator = document.getElementById('crawler-review-indicator');

    if (crawlerWorkflowInput && crawlerDefaultWorkflow && !crawlerWorkflowInput.value) {
      crawlerWorkflowInput.value = crawlerDefaultWorkflow;
    }
    if (crawlerProviderInput && !crawlerProviderInput.value) {
      crawlerProviderInput.value = 'web';
    }
    if (crawlerShadowToggle && crawlerShadowToggle instanceof HTMLInputElement) {
      crawlerShadowToggle.checked = Boolean(crawlerShadowDefault);
    }
    if (crawlerDryRunToggle && crawlerDryRunToggle instanceof HTMLInputElement) {
      crawlerDryRunToggle.checked = Boolean(crawlerDryRunDefault);
    }

    function syncCrawlerFetchUI() {
      const fetchActive = !(crawlerFetchToggle instanceof HTMLInputElement) || crawlerFetchToggle.checked;
      if (crawlerContentWrapper) {
        if (fetchActive) {
          crawlerContentWrapper.classList.add('hidden');
        } else {
          crawlerContentWrapper.classList.remove('hidden');
        }
      }
      if (crawlerContentInput && crawlerContentInput instanceof HTMLTextAreaElement) {
        crawlerContentInput.disabled = fetchActive;
      }
    }

    function syncCrawlerSnapshotUI() {
      const snapshotActive = crawlerSnapshotToggle instanceof HTMLInputElement ? crawlerSnapshotToggle.checked : false;
      if (crawlerSnapshotLabelWrapper) {
        if (snapshotActive) {
          crawlerSnapshotLabelWrapper.classList.remove('hidden');
        } else {
          crawlerSnapshotLabelWrapper.classList.add('hidden');
        }
      }
      if (crawlerSnapshotLabelInput && crawlerSnapshotLabelInput instanceof HTMLInputElement) {
        crawlerSnapshotLabelInput.disabled = !snapshotActive;
      }
    }

    syncCrawlerFetchUI();
    syncCrawlerSnapshotUI();

    if (crawlerFetchToggle && crawlerFetchToggle instanceof HTMLInputElement) {
      crawlerFetchToggle.addEventListener('change', function () {
        syncCrawlerFetchUI();
      });
    }
    if (crawlerSnapshotToggle && crawlerSnapshotToggle instanceof HTMLInputElement) {
      crawlerSnapshotToggle.addEventListener('change', function () {
        syncCrawlerSnapshotUI();
      });
    }

    function clearCrawlerError() {
      if (!crawlerErrorBox) {
        return;
      }
      crawlerErrorBox.textContent = '';
      crawlerErrorBox.classList.add('hidden');
    }

    function showCrawlerError(message) {
      if (!crawlerErrorBox) {
        return;
      }
      crawlerErrorBox.textContent = message;
      crawlerErrorBox.classList.remove('hidden');
    }

    function setCrawlerJson(data) {
      if (!crawlerJson) {
        return;
      }
      if (data === null || data === undefined) {
        crawlerJson.textContent = '';
        return;
      }
      try {
        crawlerJson.textContent = JSON.stringify(data, null, 2);
      } catch (err) {
        crawlerJson.textContent = String(data);
      }
    }

    function renderCrawlerTransitions(transitions) {
      if (!crawlerTransitionsContainer) {
        return;
      }
      crawlerTransitionsContainer.innerHTML = '';
      if (!Array.isArray(transitions) || !transitions.length) {
        const placeholder = document.createElement('p');
        placeholder.className = 'text-sm text-slate-500';
        placeholder.textContent = 'Keine Transitions vorhanden.';
        crawlerTransitionsContainer.appendChild(placeholder);
        return;
      }
      transitions.forEach(function (entry) {
        if (!entry || typeof entry !== 'object') {
          return;
        }
        const origin =
          typeof entry.origin === 'string' && entry.origin.trim()
            ? entry.origin.trim()
            : '–';
        const transitionsMap =
          entry.transitions && typeof entry.transitions === 'object'
            ? entry.transitions
            : {};
        const wrapper = document.createElement('article');
        wrapper.className = 'space-y-3 rounded-lg border border-slate-200 bg-slate-50 p-4 shadow-sm';

        const header = document.createElement('div');
        header.className = 'flex flex-col gap-1';
        const title = document.createElement('span');
        title.className = 'break-all text-sm font-semibold text-slate-700';
        title.textContent = origin;
        header.appendChild(title);
        const stepInfo = document.createElement('span');
        stepInfo.className = 'text-xs text-slate-500';
        stepInfo.textContent = Object.keys(transitionsMap).length + ' Schritte';
        header.appendChild(stepInfo);
        wrapper.appendChild(header);

        const entries = Object.entries(transitionsMap);
        if (!entries.length) {
          const placeholder = document.createElement('p');
          placeholder.className = 'text-xs text-slate-500';
          placeholder.textContent = 'Keine Transitions vorhanden.';
          wrapper.appendChild(placeholder);
        } else {
          entries.forEach(function (transitionEntry) {
            const name = transitionEntry[0];
            const payload = transitionEntry[1] || {};
            const card = document.createElement('div');
            card.className = 'space-y-2 rounded-md border border-slate-200 bg-white p-3';

            const topRow = document.createElement('div');
            topRow.className = 'flex items-center justify-between gap-3 text-xs font-semibold text-slate-700';
            const nameEl = document.createElement('span');
            nameEl.textContent = name;
            const decisionEl = document.createElement('code');
            decisionEl.className = 'rounded bg-slate-100 px-2 py-0.5 text-[0.65rem] uppercase tracking-wide text-slate-700';
            decisionEl.textContent = typeof payload.decision === 'string' ? payload.decision : '–';
            topRow.appendChild(nameEl);
            topRow.appendChild(decisionEl);
            card.appendChild(topRow);

            const detailKeys = Object.keys(payload).filter(function (key) {
              return key !== 'decision';
            });
            if (detailKeys.length) {
              const detailList = document.createElement('dl');
              detailList.className = 'grid grid-cols-2 gap-x-3 gap-y-1 text-[0.65rem] text-slate-600';
              detailKeys.forEach(function (key) {
                const dt = document.createElement('dt');
                dt.className = 'font-medium';
                dt.textContent = key;
                const dd = document.createElement('dd');
                dd.className = 'text-right break-all';
                const value = payload[key];
                if (value === null || value === undefined) {
                  dd.textContent = '–';
                } else if (typeof value === 'object') {
                  try {
                    dd.textContent = JSON.stringify(value);
                  } catch (err) {
                    dd.textContent = String(value);
                  }
                } else {
                  dd.textContent = String(value);
                }
                detailList.appendChild(dt);
                detailList.appendChild(dd);
              });
              card.appendChild(detailList);
            }

            wrapper.appendChild(card);
          });
        }

        crawlerTransitionsContainer.appendChild(wrapper);
      });
    }

    function formatCountSummary(values, options) {
      const opts = options || {};
      const mapValue =
        typeof opts.mapValue === 'function'
          ? opts.mapValue
          : function (value) {
              return value;
            };
      const emptyLabel = opts.emptyLabel || '–';
      const counts = new Map();
      values.forEach(function (rawValue) {
        let mapped = mapValue(rawValue);
        if (mapped === undefined || mapped === null || mapped === '') {
          mapped = '–';
        }
        const key = String(mapped);
        counts.set(key, (counts.get(key) || 0) + 1);
      });
      if (!counts.size) {
        return emptyLabel;
      }
      const parts = [];
      counts.forEach(function (count, key) {
        if (key === '–') {
          parts.push('–');
          return;
        }
        if (count <= 1) {
          parts.push(key);
        } else {
          parts.push(key + ' ×' + count);
        }
      });
      return parts.join(', ') || emptyLabel;
    }

    function formatNumberValue(value) {
      if (typeof value !== 'number' || !Number.isFinite(value)) {
        return value;
      }
      try {
        return new Intl.NumberFormat('de-DE').format(value);
      } catch (err) {
        return value;
      }
    }

    function renderCrawlerOriginOutcomes(origins, telemetryByOrigin, data) {
      if (!crawlerOriginOutcomes) {
        return;
      }
      crawlerOriginOutcomes.innerHTML = '';
      if (!Array.isArray(origins) || !origins.length) {
        const placeholder = document.createElement('p');
        placeholder.className = 'text-xs text-slate-500';
        placeholder.textContent = 'Noch keine Ausführung gestartet.';
        crawlerOriginOutcomes.appendChild(placeholder);
        return;
      }
      origins.forEach(function (origin) {
        if (!origin || typeof origin !== 'object') {
          return;
        }
        const card = document.createElement('article');
        card.className = 'space-y-2 rounded-md border border-slate-200 bg-white p-3 shadow-sm';
        const header = document.createElement('div');
        header.className = 'flex flex-col gap-1';
        const originKey =
          typeof origin.origin === 'string' && origin.origin.trim()
            ? origin.origin.trim()
            : typeof origin.url === 'string' && origin.url.trim()
            ? origin.url.trim()
            : '–';
        const title = document.createElement('span');
        title.className = 'break-all text-sm font-semibold text-slate-700';
        title.textContent = originKey;
        header.appendChild(title);
        if (typeof origin.collection_id === 'string' && origin.collection_id.trim()) {
          const collectionBadge = document.createElement('span');
          collectionBadge.className = 'text-xs text-slate-500';
          collectionBadge.textContent = 'Collection: ' + origin.collection_id.trim();
          header.appendChild(collectionBadge);
        }
        card.appendChild(header);

        const list = document.createElement('dl');
        list.className = 'grid grid-cols-2 gap-x-3 gap-y-1 text-xs text-slate-600';

        const addRow = function (label, value) {
          const dt = document.createElement('dt');
          dt.className = 'font-medium text-slate-600';
          dt.textContent = label;
          const dd = document.createElement('dd');
          dd.className = 'text-right text-slate-700 break-all';
          dd.textContent = value && value !== '' ? value : '–';
          list.appendChild(dt);
          list.appendChild(dd);
        };

        const control = origin.control && typeof origin.control === 'object' ? origin.control : {};
        const ingestAction =
          typeof origin.ingest_action === 'string' && origin.ingest_action.trim()
            ? origin.ingest_action.trim()
            : origin.result && typeof origin.result === 'object' && typeof origin.result.decision === 'string' && origin.result.decision.trim()
            ? origin.result.decision.trim()
            : '–';
        addRow('Ingestion', ingestAction);
        addRow(
          'Graph Decision',
          origin.result && typeof origin.result.decision === 'string'
            ? origin.result.decision
            : '–'
        );

        const reviewCandidate =
          typeof origin.review === 'string'
            ? origin.review
            : typeof control.review === 'string'
            ? control.review
            : null;
        const normalizedReview = reviewCandidate
          ? normalizeCrawlerManualReview(reviewCandidate) || reviewCandidate
          : '–';
        addRow('Review', normalizedReview || '–');

        const manualCandidate =
          typeof control.manual_review === 'string'
            ? control.manual_review
            : null;
        const normalizedManual = manualCandidate
          ? normalizeCrawlerManualReview(manualCandidate) || manualCandidate
          : normalizedReview || '–';
        addRow('Manual Status', normalizedManual || '–');

        const modeValue =
          typeof control.mode === 'string' && control.mode.trim()
            ? control.mode.trim()
            : typeof data.mode === 'string' && data.mode.trim()
            ? data.mode.trim()
            : '';
        if (modeValue) {
          addRow('Modus', modeValue);
        }

        if (Object.prototype.hasOwnProperty.call(control, 'shadow_mode')) {
          addRow('Shadow', String(Boolean(control.shadow_mode)));
        } else if (Object.prototype.hasOwnProperty.call(origin, 'shadow_mode')) {
          addRow('Shadow', String(Boolean(origin.shadow_mode)));
        }

        if (Object.prototype.hasOwnProperty.call(control, 'dry_run')) {
          addRow('Dry Run', String(Boolean(control.dry_run)));
        } else if (Object.prototype.hasOwnProperty.call(origin, 'dry_run')) {
          addRow('Dry Run', String(Boolean(origin.dry_run)));
        }

        if (origin.ingestion_run_id) {
          addRow('Ingestion Run', origin.ingestion_run_id);
        }
        if (origin.graph_run_id) {
          addRow('Graph Run', origin.graph_run_id);
        }

        const telemetryEntry =
          telemetryByOrigin.get(
            typeof origin.origin === 'string' && origin.origin.trim()
              ? origin.origin.trim()
              : ''
          ) ||
          telemetryByOrigin.get(
            typeof origin.url === 'string' && origin.url.trim() ? origin.url.trim() : ''
          );
        if (telemetryEntry) {
          addRow(
            'Fetch',
            typeof telemetryEntry.fetch_used === 'boolean'
              ? String(telemetryEntry.fetch_used)
              : '–'
          );
          addRow(
            'HTTP Status',
            telemetryEntry.http_status !== undefined && telemetryEntry.http_status !== null
              ? String(telemetryEntry.http_status)
              : '–'
          );
          addRow(
            'Fetched Bytes',
            typeof telemetryEntry.fetched_bytes === 'number'
              ? formatNumberValue(telemetryEntry.fetched_bytes)
              : telemetryEntry.fetched_bytes
              ? String(telemetryEntry.fetched_bytes)
              : '–'
          );
          if (telemetryEntry.snapshot_label) {
            addRow('Snapshot Label', telemetryEntry.snapshot_label);
          }
          if (telemetryEntry.snapshot_path) {
            addRow('Snapshot Path', telemetryEntry.snapshot_path);
          }
          if (telemetryEntry.snapshot_sha256) {
            addRow('Snapshot SHA', telemetryEntry.snapshot_sha256);
          }
        } else if (origin.state && typeof origin.state === 'object') {
          const state = origin.state;
          if (Object.prototype.hasOwnProperty.call(state, 'snapshot_requested')) {
            addRow('Snapshot', String(Boolean(state.snapshot_requested)));
          }
          if (state.snapshot_label) {
            addRow('Snapshot Label', state.snapshot_label);
          }
          if (state.snapshot_path) {
            addRow('Snapshot Path', state.snapshot_path);
          }
          if (state.snapshot_sha256) {
            addRow('Snapshot SHA', state.snapshot_sha256);
          }
        }

        card.appendChild(list);
        crawlerOriginOutcomes.appendChild(card);
      });
    }

    function renderCrawlerSummary(data) {
      const origins = Array.isArray(data && data.origins) ? data.origins : [];
      const telemetry = Array.isArray(data && data.telemetry) ? data.telemetry : [];
      const telemetryByOrigin = new Map();
      telemetry.forEach(function (entry) {
        if (!entry || typeof entry !== 'object') {
          return;
        }
        const key =
          typeof entry.origin === 'string' && entry.origin.trim()
            ? entry.origin.trim()
            : null;
        if (key) {
          telemetryByOrigin.set(key, entry);
        }
      });

      const decisionValues = [];
      const reviewValues = [];
      const shadowValues = [];
      const runIds = [];
      const fetchUsedValues = [];
      const httpStatusValues = [];
      const fetchedBytesValues = [];
      const snapshotRequestedValues = [];
      const snapshotLabelValues = [];
      const snapshotPathValues = [];
      const snapshotShaValues = [];

      origins.forEach(function (origin) {
        if (!origin || typeof origin !== 'object') {
          return;
        }
        const control = origin.control && typeof origin.control === 'object' ? origin.control : {};
        const ingestAction =
          typeof origin.ingest_action === 'string' && origin.ingest_action.trim()
            ? origin.ingest_action.trim()
            : origin.result && typeof origin.result === 'object' && typeof origin.result.decision === 'string' && origin.result.decision.trim()
            ? origin.result.decision.trim()
            : '–';
        decisionValues.push(ingestAction);

        if (typeof origin.graph_run_id === 'string' && origin.graph_run_id.trim()) {
          runIds.push(origin.graph_run_id.trim());
        }

        const reviewCandidate =
          typeof origin.review === 'string'
            ? origin.review
            : typeof control.review === 'string'
            ? control.review
            : null;
        const normalizedReview = reviewCandidate
          ? normalizeCrawlerManualReview(reviewCandidate) || reviewCandidate
          : null;
        reviewValues.push(normalizedReview || '–');

        if (Object.prototype.hasOwnProperty.call(control, 'shadow_mode')) {
          shadowValues.push(Boolean(control.shadow_mode));
        }

        const originKey =
          typeof origin.origin === 'string' && origin.origin.trim()
            ? origin.origin.trim()
            : typeof origin.url === 'string' && origin.url.trim()
            ? origin.url.trim()
            : '';
        const telemetryEntry = originKey ? telemetryByOrigin.get(originKey) : null;
        if (telemetryEntry) {
          fetchUsedValues.push(telemetryEntry.fetch_used);
          httpStatusValues.push(telemetryEntry.http_status);
          fetchedBytesValues.push(telemetryEntry.fetched_bytes);
          snapshotRequestedValues.push(telemetryEntry.snapshot_requested);
          snapshotLabelValues.push(telemetryEntry.snapshot_label);
          snapshotPathValues.push(telemetryEntry.snapshot_path);
          snapshotShaValues.push(telemetryEntry.snapshot_sha256);
        } else if (origin.state && typeof origin.state === 'object') {
          const state = origin.state;
          if (Object.prototype.hasOwnProperty.call(state, 'snapshot_requested')) {
            snapshotRequestedValues.push(state.snapshot_requested);
          }
          if (Object.prototype.hasOwnProperty.call(state, 'snapshot_label')) {
            snapshotLabelValues.push(state.snapshot_label);
          }
          if (Object.prototype.hasOwnProperty.call(state, 'snapshot_path')) {
            snapshotPathValues.push(state.snapshot_path);
          }
          if (Object.prototype.hasOwnProperty.call(state, 'snapshot_sha256')) {
            snapshotShaValues.push(state.snapshot_sha256);
          }
        }
      });

      if (!fetchUsedValues.length && Object.prototype.hasOwnProperty.call(data || {}, 'fetch_used')) {
        fetchUsedValues.push(data.fetch_used);
      }
      if (!httpStatusValues.length && Object.prototype.hasOwnProperty.call(data || {}, 'http_status')) {
        httpStatusValues.push(data.http_status);
      }
      if (!fetchedBytesValues.length && Object.prototype.hasOwnProperty.call(data || {}, 'fetched_bytes')) {
        fetchedBytesValues.push(data.fetched_bytes);
      }
      if (!snapshotRequestedValues.length && Object.prototype.hasOwnProperty.call(data || {}, 'snapshot_requested')) {
        snapshotRequestedValues.push(data.snapshot_requested);
      }
      if (!snapshotLabelValues.length && Object.prototype.hasOwnProperty.call(data || {}, 'snapshot_label')) {
        snapshotLabelValues.push(data.snapshot_label);
      }
      if (!snapshotPathValues.length && Object.prototype.hasOwnProperty.call(data || {}, 'snapshot_path')) {
        snapshotPathValues.push(data.snapshot_path);
      }
      if (!snapshotShaValues.length && Object.prototype.hasOwnProperty.call(data || {}, 'snapshot_sha256')) {
        snapshotShaValues.push(data.snapshot_sha256);
      }

      if (crawlerDecisionDisplay) {
        crawlerDecisionDisplay.textContent = formatCountSummary(decisionValues, {
          emptyLabel: '–',
        });
      }
      if (crawlerManualStatus) {
        crawlerManualStatus.textContent = formatCountSummary(reviewValues, {
          emptyLabel: '–',
        });
      }
      if (crawlerShadowState) {
        crawlerShadowState.textContent = formatCountSummary(shadowValues, {
          emptyLabel: '–',
          mapValue: function (value) {
            return typeof value === 'boolean' ? String(value) : value;
          },
        });
      }
      if (crawlerFetchUsedDisplay) {
        crawlerFetchUsedDisplay.textContent = formatCountSummary(fetchUsedValues, {
          emptyLabel: '–',
          mapValue: function (value) {
            if (typeof value === 'boolean') {
              return String(value);
            }
            return value;
          },
        });
      }
      if (crawlerHttpStatusDisplay) {
        crawlerHttpStatusDisplay.textContent = formatCountSummary(httpStatusValues, {
          emptyLabel: '–',
        });
      }
      if (crawlerFetchedBytesDisplay) {
        crawlerFetchedBytesDisplay.textContent = formatCountSummary(fetchedBytesValues, {
          emptyLabel: '–',
          mapValue: function (value) {
            if (typeof value === 'number' && Number.isFinite(value)) {
              return formatNumberValue(value);
            }
            if (typeof value === 'string' && value.trim()) {
              return value.trim();
            }
            return value;
          },
        });
      }
      if (crawlerSnapshotRequestedDisplay) {
        crawlerSnapshotRequestedDisplay.textContent = formatCountSummary(snapshotRequestedValues, {
          emptyLabel: '–',
          mapValue: function (value) {
            if (typeof value === 'boolean') {
              return String(value);
            }
            return value;
          },
        });
      }
      if (crawlerSnapshotLabelDisplay) {
        crawlerSnapshotLabelDisplay.textContent = formatCountSummary(snapshotLabelValues, {
          emptyLabel: '–',
        });
      }
      if (crawlerSnapshotPathDisplay) {
        crawlerSnapshotPathDisplay.textContent = formatCountSummary(snapshotPathValues, {
          emptyLabel: '–',
        });
      }
      if (crawlerSnapshotShaDisplay) {
        crawlerSnapshotShaDisplay.textContent = formatCountSummary(snapshotShaValues, {
          emptyLabel: '–',
        });
      }
      if (crawlerRunId) {
        if (runIds.length === 1) {
          crawlerRunId.textContent = runIds[0];
        } else if (runIds.length > 1) {
          crawlerRunId.textContent = runIds.length + ' Läufe';
        } else {
          crawlerRunId.textContent = '–';
        }
      }
      if (crawlerReviewIndicator) {
        if (!origins.length) {
          crawlerReviewIndicator.textContent = 'Review offen: –';
        } else {
          const pending = reviewValues.filter(function (value) {
            return value === 'required';
          }).length;
          if (pending > 0) {
            crawlerReviewIndicator.textContent =
              'Review offen: ' + pending + (pending === 1 ? ' URL' : ' URLs');
          } else {
            crawlerReviewIndicator.textContent = 'Review offen: 0';
          }
        }
      }

      renderCrawlerOriginOutcomes(origins, telemetryByOrigin, data || {});
    }

    function enableCrawlerActions(enabled) {
      const allow = Boolean(enabled);
      if (crawlerApproveButton) {
        crawlerApproveButton.disabled = !allow;
      }
      if (crawlerRejectButton) {
        crawlerRejectButton.disabled = !allow;
      }
    }

    let crawlerHasRun = false;

    function handleCrawlerResponse(data) {
      crawlerHasRun = true;
      clearCrawlerError();
      renderCrawlerSummary(data);
      renderCrawlerTransitions(data && data.transitions);
      setCrawlerJson(data);
      enableCrawlerActions(true);
    }

    async function executeCrawler(payload) {
      try {
        const headers = buildHeaders({ 'Content-Type': 'application/json' });
        const csrfToken = getCsrfToken();
        if (csrfToken) {
          headers['X-CSRFToken'] = csrfToken;
        }
        const response = await fetch(crawlerRunnerUrl, {
          method: 'POST',
          headers,
          body: JSON.stringify(payload),
          credentials: 'include',
        });
        const [res, data] = await parseJsonOrText(response);
        if (!res.ok) {
          const detail = data && typeof data === 'object' && data.detail ? data.detail : res.status + ' ' + res.statusText;
          showCrawlerError(detail);
          enableCrawlerActions(crawlerHasRun);
          return;
        }
        handleCrawlerResponse(data);
      } catch (err) {
        showCrawlerError('Crawler Request fehlgeschlagen.');
        enableCrawlerActions(crawlerHasRun);
      }
    }

    function parseOriginList(rawValue) {
      if (typeof rawValue !== 'string') {
        return [];
      }
      return rawValue
        .split(/[\n,]/)
        .map(function (entry) {
          return entry.trim();
        })
        .filter(Boolean);
    }

    function collectCrawlerConfig(manualOverride) {
      const modeValue =
        crawlerModeSelect && crawlerModeSelect instanceof HTMLSelectElement
          ? crawlerModeSelect.value.trim()
          : '';
      const reviewValue =
        crawlerReviewSelect && crawlerReviewSelect instanceof HTMLSelectElement
          ? crawlerReviewSelect.value.trim()
          : '';

      const config = {
        workflowId: crawlerWorkflowInput ? crawlerWorkflowInput.value : '',
        mode: modeValue || 'ingest',
        originUrl: crawlerOriginInput ? crawlerOriginInput.value : '',
        originUrls:
          crawlerOriginListInput && crawlerOriginListInput instanceof HTMLTextAreaElement
            ? parseOriginList(crawlerOriginListInput.value)
            : [],
        title: crawlerTitleInput ? crawlerTitleInput.value : '',
        language: crawlerLanguageInput ? crawlerLanguageInput.value : '',
        provider: crawlerProviderInput ? crawlerProviderInput.value : '',
        tags: crawlerTagsInput ? crawlerTagsInput.value : '',
        contentType: crawlerContentTypeInput ? crawlerContentTypeInput.value : '',
        fetch: crawlerFetchToggle instanceof HTMLInputElement ? crawlerFetchToggle.checked : true,
        content: crawlerContentInput ? crawlerContentInput.value : '',
        snapshot: crawlerSnapshotToggle instanceof HTMLInputElement ? crawlerSnapshotToggle.checked : false,
        snapshotLabel: crawlerSnapshotLabelInput ? crawlerSnapshotLabelInput.value : '',
        maxDocumentBytes: crawlerMaxBytesInput ? crawlerMaxBytesInput.value : '',
        shadowMode: crawlerShadowToggle instanceof HTMLInputElement ? crawlerShadowToggle.checked : false,
        dryRun: crawlerDryRunToggle instanceof HTMLInputElement ? crawlerDryRunToggle.checked : false,
        review: reviewValue || 'required',
      };

      if (!config.originUrls.length) {
        delete config.originUrls;
      }

      let collectionCandidate = '';
      if (crawlerCollectionInput && crawlerCollectionInput instanceof HTMLInputElement && crawlerCollectionInput.value.trim()) {
        collectionCandidate = crawlerCollectionInput.value.trim();
      } else if (currentCollectionId) {
        collectionCandidate = currentCollectionId;
      }
      if (collectionCandidate) {
        const resolvedCollection = requireCollection({
          rawValue: collectionCandidate,
          allowResolverFallback: false,
        });
        if (resolvedCollection) {
          config.collectionId = resolvedCollection;
        }
      }

      if (
        config.maxDocumentBytes !== undefined &&
        config.maxDocumentBytes !== null &&
        config.maxDocumentBytes !== ''
      ) {
        config.limits = { maxDocumentBytes: config.maxDocumentBytes };
      }

      if (manualOverride !== undefined) {
        config.manualReview = manualOverride;
        config.review = manualOverride;
        if (crawlerReviewSelect && crawlerReviewSelect instanceof HTMLSelectElement) {
          crawlerReviewSelect.value = manualOverride;
        }
      }

      return config;
    }

    if (crawlerForm) {
      crawlerForm.addEventListener('submit', function (event) {
        event.preventDefault();
        if (!crawlerRunnerUrl) {
          showCrawlerError('Crawler Endpoint nicht konfiguriert.');
          return;
        }
        clearCrawlerError();
        const config = collectCrawlerConfig();
        const hasPrimaryOrigin = typeof config.originUrl === 'string' && config.originUrl.trim();
        const hasAdditionalOrigins = Array.isArray(config.originUrls) && config.originUrls.length > 0;
        if (!hasPrimaryOrigin && !hasAdditionalOrigins) {
          showCrawlerError('Bitte mindestens eine Origin URL angeben.');
          return;
        }
        if (!config.fetch && !config.content) {
          showCrawlerError('Content ist erforderlich, wenn Live Fetch deaktiviert ist.');
          return;
        }
        const payload = buildCrawlerPayload(config);
        const payloadHasOrigin = typeof payload.origin_url === 'string' && payload.origin_url.trim();
        const payloadHasOriginsArray = Array.isArray(payload.origins) && payload.origins.length > 0;
        if (!payloadHasOrigin && !payloadHasOriginsArray) {
          showCrawlerError('Bitte mindestens eine Origin URL angeben.');
          return;
        }
        if (Object.prototype.hasOwnProperty.call(payload, 'fetch') && payload.fetch === false) {
          const hasContent = Object.prototype.hasOwnProperty.call(payload, 'content') && typeof payload.content === 'string' && payload.content.length > 0;
          if (!hasContent) {
            showCrawlerError('Content ist erforderlich, wenn Live Fetch deaktiviert ist.');
            return;
          }
        }
        enableCrawlerActions(false);
        executeCrawler(payload);
      });
    }

    if (crawlerApproveButton) {
      crawlerApproveButton.addEventListener('click', function () {
        if (!crawlerHasRun || !crawlerRunnerUrl) {
          return;
        }
        clearCrawlerError();
        const config = collectCrawlerConfig('approved');
        const payload = buildCrawlerPayload(config);
        enableCrawlerActions(false);
        executeCrawler(payload);
      });
    }

    if (crawlerRejectButton) {
      crawlerRejectButton.addEventListener('click', function () {
        if (!crawlerHasRun || !crawlerRunnerUrl) {
          return;
        }
        clearCrawlerError();
        const config = collectCrawlerConfig('rejected');
        const payload = buildCrawlerPayload(config);
        enableCrawlerActions(false);
        executeCrawler(payload);
      });
    }

    if (crawlerCopyButton) {
      crawlerCopyButton.addEventListener('click', function () {
        copyTextJSON('#crawler-json');
      });
    }

    const answerCopyButton = document.getElementById('rag-answer-copy');
    if (answerCopyButton) {
      answerCopyButton.addEventListener('click', function () {
        copyText('#rag-answer');
      });
    }

    const rawCopyButton = document.getElementById('rag-raw-copy');
    if (rawCopyButton) {
      rawCopyButton.addEventListener('click', function () {
        copyTextJSON('#rag-raw');
      });
    }

    const rawToggleControl = document.getElementById('rag-raw-toggle');
    if (rawToggleControl && rawToggleControl instanceof HTMLInputElement) {
      rawToggleControl.addEventListener('change', function (event) {
        const rawElement = document.getElementById('rag-raw');
        if (!rawElement) {
          return;
        }
        if (event.target.checked) {
          rawElement.classList.remove('hidden');
        } else {
          rawElement.classList.add('hidden');
        }
      });
    }

    const uploadForm = document.getElementById('upload-form');
    const uploadResponseTarget = 'upload-response';
    if (uploadForm) {
      uploadForm.addEventListener('submit', async function (event) {
        event.preventDefault();
        const fileInput = document.getElementById('upload-file');
        const metadataInput = document.getElementById('upload-metadata');
        if (!fileInput || !(fileInput instanceof HTMLInputElement) || !fileInput.files?.length) {
          renderJson(uploadResponseTarget, 'Please choose a file to upload.');
          return;
        }

        const collectionScope = requireCollection({ allowResolverFallback: false });
        if (!collectionScope) {
          renderJson(uploadResponseTarget, 'Bitte zuerst eine Collection auswählen.');
          return;
        }

        const formData = new FormData();
        formData.append('file', fileInput.files[0]);
        if (metadataInput && metadataInput.value.trim()) {
          formData.append('metadata', metadataInput.value.trim());
        }

        const headers = buildHeaders();
        const csrfToken = getCsrfToken();
        if (csrfToken) {
          headers['X-CSRFToken'] = csrfToken;
        }

        try {
          const response = await fetch('/ai/rag/documents/upload/', {
            method: 'POST',
            headers,
            body: formData,
            credentials: 'include'
          });
          const text = await response.text();
          try {
            const data = JSON.parse(text);
            prettyPrint(uploadResponseTarget, data);
            if (data && typeof data === 'object' && data.ingestion_run_id) {
              updateLastRunId(data.ingestion_run_id);
            }
          } catch (err) {
            renderJson(uploadResponseTarget, text);
          }
        } catch (error) {
          renderJson(uploadResponseTarget, String(error));
        }
      });
    }

    const ingestionForm = document.getElementById('ingestion-form');
    const ingestionResponseTarget = 'ingestion-response';
    if (ingestionForm) {
      ingestionForm.addEventListener('submit', async function (event) {
        event.preventDefault();
        const docInput = document.getElementById('ingestion-document-ids');
        if (!docInput || !(docInput instanceof HTMLTextAreaElement)) {
          renderJson(ingestionResponseTarget, 'Document input not found.');
          return;
        }
        const rawValue = docInput.value.trim();
        if (!rawValue) {
          renderJson(ingestionResponseTarget, 'Bitte mindestens eine document_id angeben.');
          return;
        }
        const docs = rawValue
          .split(/[\n,]/)
          .map(function (entry) { return entry.trim(); })
          .filter(function (entry) { return Boolean(entry); });
        if (!docs.length) {
          renderJson(ingestionResponseTarget, 'Bitte gültige document_ids angeben.');
          return;
        }

        const profileSelect = document.getElementById('ingestion-profile');
        const selectedProfile =
          profileSelect && profileSelect instanceof HTMLSelectElement && profileSelect.value.trim()
            ? profileSelect.value.trim()
            : defaultEmbeddingProfile;

        const collectionScope = requireCollection({ allowResolverFallback: true });
        if (!collectionScope) {
          renderJson(ingestionResponseTarget, 'Bitte zuerst eine Collection auswählen.');
          return;
        }

        const payload = {
          document_ids: docs,
          embedding_profile: selectedProfile,
          collection_id: collectionScope,
        };

        const headers = buildHeaders({
          'Content-Type': 'application/json',
          Accept: 'application/json'
        });
        const csrfToken = getCsrfToken();
        if (csrfToken) {
          headers['X-CSRFToken'] = csrfToken;
        }

        try {
          const response = await fetch('/ai/rag/ingestion/run/', {
            method: 'POST',
            headers,
            body: JSON.stringify(payload),
            credentials: 'include'
          });
          const text = await response.text();
          try {
            const data = JSON.parse(text);
            prettyPrint(ingestionResponseTarget, data);
            if (data && typeof data === 'object' && data.ingestion_run_id) {
              updateLastRunId(data.ingestion_run_id);
            }
          } catch (err) {
            renderJson(ingestionResponseTarget, text);
          }
        } catch (error) {
          renderJson(ingestionResponseTarget, String(error));
        }
      });
    }

    const statusResponseTarget = 'status-response';

    async function refreshStatus() {
      requireCollection({ allowResolverFallback: true });
      const headers = buildHeaders({
        Accept: 'application/json'
      });
      const csrfToken = getCsrfToken();
      if (csrfToken) {
        headers['X-CSRFToken'] = csrfToken;
      }

      try {
        const response = await fetch('/ai/rag/ingestion/status/', {
          method: 'GET',
          headers,
          credentials: 'include'
        });
        const text = await response.text();
        try {
          const data = JSON.parse(text);
          prettyPrint(statusResponseTarget, data);
          if (data && typeof data === 'object' && data.run_id) {
            updateLastRunId(data.run_id);
          }
        } catch (err) {
          renderJson(statusResponseTarget, text);
        }
      } catch (error) {
        renderJson(statusResponseTarget, String(error));
      }
    }

    const statusButton = document.getElementById('status-refresh');
    if (statusButton) {
      statusButton.addEventListener('click', refreshStatus);
    }

    const queryForm = document.getElementById('query-form');
    const querySubmitBtn = document.getElementById('query-submit');
    // Ensure clicking the button triggers the submit handler across browsers
    if (queryForm && querySubmitBtn) {
      querySubmitBtn.addEventListener('click', function (e) {
        try {
          if (typeof queryForm.requestSubmit === 'function') {
            e.preventDefault();
            queryForm.requestSubmit();
            return;
          }
        } catch (_) {}
        // Fallback: dispatch a cancellable submit event
        try {
          const evt = new Event('submit', { bubbles: true, cancelable: true });
          const cancelled = !queryForm.dispatchEvent(evt);
          if (cancelled) {
            e.preventDefault();
          }
        } catch (_) {}
      });
    }
    if (queryForm) {
      queryForm.addEventListener('submit', async function (event) {
        event.preventDefault();
        clearError();
        resetRagView();
        const queryText = document.getElementById('query-text');
        if (!queryText || !(queryText instanceof HTMLTextAreaElement)) {
          showError('Query input not found.');
          return;
        }
        const queryValue = queryText.value.trim();
        if (!queryValue) {
          showError('Please enter a query.');
          return;
        }

        const payload = {
          query: queryValue,
          question: queryValue,
          hybrid: {}
        };

        const processInput = document.getElementById('query-process');
        if (processInput && processInput.value.trim()) {
          payload.process = processInput.value.trim();
        }
        const collectionScope = requireCollection({ allowResolverFallback: true });
        if (collectionScope) {
          payload.collection_id = collectionScope;
        }
        const visibilitySelect = document.getElementById('query-visibility');
        if (visibilitySelect && visibilitySelect.value) {
          payload.visibility = visibilitySelect.value;
        }

        const hybridFields = [
          { id: 'hybrid-alpha', key: 'alpha', parse: parseFloat },
          { id: 'hybrid-min-sim', key: 'min_sim', parse: parseFloat },
          { id: 'hybrid-top-k', key: 'top_k', parse: function (value) { return parseInt(value, 10); } },
          { id: 'hybrid-vec-limit', key: 'vec_limit', parse: function (value) { return parseInt(value, 10); } },
          { id: 'hybrid-lex-limit', key: 'lex_limit', parse: function (value) { return parseInt(value, 10); } },
          { id: 'hybrid-max-candidates', key: 'max_candidates', parse: function (value) { return parseInt(value, 10); } },
          { id: 'hybrid-trgm-limit', key: 'trgm_limit', parse: parseFloat }
        ];

        hybridFields.forEach(function (field) {
          const input = document.getElementById(field.id);
          if (!input || !(input instanceof HTMLInputElement)) {
            return;
          }
          const value = input.value.trim();
          if (!value) {
            return;
          }
          const numberValue = field.parse(value);
          if (!Number.isFinite(numberValue)) {
            return;
          }
          payload.hybrid[field.key] = numberValue;
        });

        const headers = buildHeaders({
          'Content-Type': 'application/json',
          Accept: 'application/json'
        });
        const csrfToken = getCsrfToken();
        if (csrfToken) {
          headers['X-CSRFToken'] = csrfToken;
        }

        try {
          const response = await fetch('/v1/ai/rag/query/', {
            method: 'POST',
            headers,
            body: JSON.stringify(payload),
            credentials: 'include'
          });
          const parsed = await parseJsonOrText(response);
          const res = parsed[0];
          const obj = parsed[1];
          const rawPayload = obj && typeof obj === 'object' && '__raw' in obj ? { __raw: obj.__raw } : obj;

          if (res.ok) {
            if (obj && typeof obj === 'object' && '__raw' in obj) {
              setRaw(rawPayload);
              showError('Antwort ist kein JSON.');
              return;
            }
            const rendered = renderRagV2(obj);
            setRaw(obj);
            if (rendered) {
              clearError();
            }
            return;
          }

          if (res.status === 422 && obj && obj.code === 'retrieval_inconsistent_metadata') {
            setRaw(rawPayload);
            showError('Re-Index erforderlich: Chunks ohne tenant_id/case_id.');
            return;
          }

          setRaw(rawPayload);
          const statusText = res.statusText || 'Unbekannter Fehler';
          showError('Fehler ' + res.status + ': ' + statusText + '. Details im Raw-Tab.');
        } catch (error) {
          setRaw({ error: String(error) });
          showError('Netzwerkfehler: ' + String(error));
        }
      });
    }
  })();
</script>
{% endblock %}
