{% extends 'theme/base.html' %}

{% block title %}RAG Tools · NOESIS 2{% endblock %}

{% block content %}
<div class="space-y-10">
  <header class="space-y-2">
    <h1 class="text-3xl font-semibold tracking-tight text-slate-900">RAG Manual Testing</h1>
    <p class="max-w-2xl text-sm text-slate-600">
      Nutze diese Werkbank, um Dateien hochzuladen und Queries gegen die bestehenden RAG-Endpunkte abzufeuern.
      Alle Requests senden automatisch die aus der aktuellen Domain abgeleiteten Header
      <code class="rounded bg-slate-100 px-1 py-0.5 text-xs">X-Tenant-ID: {{ tenant_id }}</code>,
      <code class="rounded bg-slate-100 px-1 py-0.5 text-xs">X-User-ID: local</code>
      und
      <code class="rounded bg-slate-100 px-1 py-0.5 text-xs">X-Case-ID: local</code>.
    </p>
  </header>

  <section class="rounded-lg border border-slate-200 bg-white p-6 shadow-sm space-y-6">
    <div class="space-y-2">
      <h2 class="text-xl font-semibold text-slate-900">Upload Document</h2>
      <p class="text-sm text-slate-600">
        Lade eine Datei hoch, registriere sie im Dokumentenspeicher und starte automatisch eine Ingestion.
        Die Antwort enthält sowohl die <code class="rounded bg-slate-100 px-1 py-0.5 text-xs">document_id</code>
        als auch den zugehörigen <code class="rounded bg-slate-100 px-1 py-0.5 text-xs">ingestion_run_id</code>.
      </p>
    </div>

    <form id="upload-form" class="space-y-4">
      <div class="space-y-1">
        <label class="block text-sm font-medium text-slate-700" for="upload-file">Datei</label>
        <input
          class="block w-full rounded-md border border-slate-300 bg-white px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
          id="upload-file"
          name="file"
          type="file"
          required
        />
      </div>
      <div class="space-y-1">
        <div class="flex items-center justify-between gap-2">
          <label class="text-sm font-medium text-slate-700" for="upload-metadata">Metadata (optional)</label>
          <span class="text-xs text-slate-500">JSON-Struktur, z.&nbsp;B. {"case": "abc"}</span>
        </div>
        <textarea
          class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
          id="upload-metadata"
          name="metadata"
          rows="4"
        ></textarea>
      </div>
      <button
        class="inline-flex items-center rounded-md bg-slate-900 px-4 py-2 text-sm font-medium text-white shadow-sm transition hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-offset-2"
        type="submit"
      >
        Upload starten
      </button>
    </form>
    <div class="space-y-2">
      <h3 class="text-sm font-semibold uppercase tracking-wide text-slate-600">Upload Response</h3>
      <pre class="max-h-64 overflow-auto rounded-lg bg-slate-950 p-4 text-xs text-slate-100" id="upload-response"></pre>
    </div>
  </section>

  <section class="rounded-lg border border-slate-200 bg-white p-6 shadow-sm space-y-6">
    <div class="space-y-2">
      <h2 class="text-xl font-semibold text-slate-900">Ingestion Control</h2>
      <p class="text-sm text-slate-600">
        Steuere den Ingestion-Workflow Schritt für Schritt: Starte Runs für bestehende Dokumente und überwache den Status
        des letzten Durchlaufs im aktuellen Tenant- und Case-Kontext.
      </p>
    </div>

    <div class="grid gap-8 lg:grid-cols-2">
      <div class="space-y-4">
        <div class="space-y-1">
          <h3 class="text-lg font-semibold text-slate-900">Ingestion Run starten</h3>
          <p class="text-sm text-slate-600">
            Übermittle eine oder mehrere <code class="rounded bg-slate-100 px-1 py-0.5 text-xs">document_id</code>-Werte (Komma oder Zeilenumbruch)
            und wähle das gewünschte Embedding-Profil.
          </p>
        </div>
        <form id="ingestion-form" class="space-y-4">
          <div class="space-y-1">
            <label class="block text-sm font-medium text-slate-700" for="ingestion-document-ids">Document IDs</label>
            <textarea
              class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
              id="ingestion-document-ids"
              name="document_ids"
              rows="3"
              placeholder="doc-123, doc-456"
              required
            ></textarea>
          </div>
          <div class="space-y-1">
            <label class="block text-sm font-medium text-slate-700" for="ingestion-profile">Embedding Profile</label>
            <select
              class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
              id="ingestion-profile"
              name="embedding_profile"
            >
              <option value="{{ default_embedding_profile }}">{{ default_embedding_profile }}</option>
              <option value="demo">demo</option>
            </select>
          </div>
          <button
            class="inline-flex items-center rounded-md bg-slate-900 px-4 py-2 text-sm font-medium text-white shadow-sm transition hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-offset-2"
            type="submit"
          >
            Ingestion starten
          </button>
        </form>
        <div class="space-y-2">
          <h4 class="text-sm font-semibold uppercase tracking-wide text-slate-600">Ingestion Response</h4>
          <pre class="max-h-56 overflow-auto rounded-lg bg-slate-950 p-4 text-xs text-slate-100" id="ingestion-response"></pre>
        </div>
      </div>

      <div class="space-y-4">
        <div class="space-y-1">
          <h3 class="text-lg font-semibold text-slate-900">Ingestion Status</h3>
          <p class="text-sm text-slate-600">
            Lies den Status des letzten Ingestion-Runs aus. Der aktuell bekannte Run wird hier angezeigt und kann über
            den Button aktualisiert werden.
          </p>
        </div>
        <div class="rounded-md border border-dashed border-slate-300 bg-slate-50 p-4 text-sm text-slate-600">
          <p>
            Letzter Run: <code class="rounded bg-slate-200 px-1 py-0.5 text-xs" id="last-run-id">–</code>
          </p>
        </div>
        <div class="flex items-center gap-3">
          <button
            class="inline-flex items-center rounded-md bg-slate-900 px-4 py-2 text-sm font-medium text-white shadow-sm transition hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-offset-2"
            type="button"
            id="status-refresh"
          >
            Status aktualisieren
          </button>
          <span class="text-xs text-slate-500">Antwort wird unten angezeigt.</span>
        </div>
        <div class="space-y-2">
          <h4 class="text-sm font-semibold uppercase tracking-wide text-slate-600">Status Response</h4>
          <pre class="max-h-56 overflow-auto rounded-lg bg-slate-950 p-4 text-xs text-slate-100" id="status-response"></pre>
        </div>
      </div>
    </div>
  </section>

  <section class="rounded-lg border border-slate-200 bg-white p-6 shadow-sm">
    <div class="space-y-2">
      <h2 class="text-xl font-semibold text-slate-900">Query</h2>
      <p class="text-sm text-slate-600">
        Führe Queries gegen den Wissensspeicher aus. Über optionale Felder kannst du Routing und Hybrid-Search Feintuning testen.
      </p>
    </div>
    <form id="query-form" class="mt-6 grid gap-6 md:grid-cols-2">
      <div class="md:col-span-2 space-y-1">
        <div class="flex items-center justify-between gap-2">
          <label class="text-sm font-medium text-slate-700" for="query-text">Query</label>
          <span class="text-xs text-slate-500">Wird zusätzlich als <code>question</code> gesendet.</span>
        </div>
        <textarea
          class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
          id="query-text"
          name="query"
          rows="3"
          required
        ></textarea>
      </div>
      <div class="space-y-1">
        <label class="text-sm font-medium text-slate-700" for="query-process">Process</label>
        <input
          class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
          id="query-process"
          name="process"
          type="text"
          placeholder="z. B. classification"
        />
        <p class="text-xs text-slate-500">Optional: Erzwingt einen konkreten Prozess-Flow.</p>
      </div>
      <div class="space-y-1">
        <label class="text-sm font-medium text-slate-700" for="query-doc-class">Doc class</label>
        <input
          class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
          id="query-doc-class"
          name="doc_class"
          type="text"
          placeholder="z. B. contract"
        />
        <p class="text-xs text-slate-500">Optional: Beschränkt die Suche auf einen Dokumenttyp.</p>
      </div>
      <div class="space-y-1">
        <label class="text-sm font-medium text-slate-700" for="query-visibility">Visibility</label>
        <select
          class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
          id="query-visibility"
          name="visibility"
        >
          <option value="">Default</option>
          <option value="active">active</option>
          <option value="all">all</option>
          <option value="deleted">deleted</option>
        </select>
        <p class="text-xs text-slate-500">Steuert, welche Dokument-Zustände durchsucht werden.</p>
      </div>
      <fieldset class="md:col-span-2 space-y-4 rounded-md border border-dashed border-slate-300 p-4">
        <legend class="px-1 text-sm font-semibold uppercase tracking-wide text-slate-600">Hybrid Parameter</legend>
        <p class="text-xs text-slate-500">
          Mit diesen Werten kannst du die Balance zwischen Vektor- und Lexikal-Suche steuern. Leere Felder werden nicht gesendet.
        </p>
        <div class="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
          <div class="space-y-1">
            <label class="text-sm font-medium text-slate-700" for="hybrid-alpha">alpha</label>
            <input
              class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
              id="hybrid-alpha"
              name="alpha"
              type="number"
              step="0.01"
              min="0"
              max="1"
              placeholder="0–1"
            />
            <p class="text-xs text-slate-500">Mischverhältnis Hybrid-Suche (0 = rein lexikalisch, 1 = rein vektorbasiert).</p>
          </div>
          <div class="space-y-1">
            <label class="text-sm font-medium text-slate-700" for="hybrid-min-sim">min_sim</label>
            <input
              class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
              id="hybrid-min-sim"
              name="min_sim"
              type="number"
              step="0.01"
              min="0"
              max="1"
              placeholder="z. B. 0.35"
            />
            <p class="text-xs text-slate-500">Mindestsimilarität für Treffer im Vektorraum.</p>
          </div>
          <div class="space-y-1">
            <label class="text-sm font-medium text-slate-700" for="hybrid-top-k">top_k</label>
            <input
              class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
              id="hybrid-top-k"
              name="top_k"
              type="number"
              min="1"
              placeholder="Standard 5"
            />
            <p class="text-xs text-slate-500">Anzahl der kombinierten Kandidaten aus beiden Retrieval-Wege.</p>
          </div>
          <div class="space-y-1">
            <label class="text-sm font-medium text-slate-700" for="hybrid-vec-limit">vec_limit</label>
            <input
              class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
              id="hybrid-vec-limit"
              name="vec_limit"
              type="number"
              min="1"
              placeholder="Vektor-Kandidaten"
            />
            <p class="text-xs text-slate-500">Maximale Treffer aus dem Vektorindex.</p>
          </div>
          <div class="space-y-1">
            <label class="text-sm font-medium text-slate-700" for="hybrid-lex-limit">lex_limit</label>
            <input
              class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
              id="hybrid-lex-limit"
              name="lex_limit"
              type="number"
              min="1"
              placeholder="Lexikal-Kandidaten"
            />
            <p class="text-xs text-slate-500">Maximale Treffer aus der BM25/Trigram Suche.</p>
          </div>
          <div class="space-y-1">
            <label class="text-sm font-medium text-slate-700" for="hybrid-max-candidates">max_candidates</label>
            <input
              class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
              id="hybrid-max-candidates"
              name="max_candidates"
              type="number"
              min="1"
              placeholder="Gesamtkandidaten"
            />
            <p class="text-xs text-slate-500">Deckel für gemergte Treffer vor Re-Ranking.</p>
          </div>
          <div class="space-y-1">
            <label class="text-sm font-medium text-slate-700" for="hybrid-trgm-limit">trgm_limit</label>
            <input
              class="block w-full rounded-md border border-slate-300 px-3 py-2 text-sm shadow-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
              id="hybrid-trgm-limit"
              name="trgm_limit"
              type="number"
              step="0.01"
              min="0"
              max="1"
              placeholder="0–1"
            />
            <p class="text-xs text-slate-500">Grenze für trigram-basierte Recall-Erweiterung.</p>
          </div>
        </div>
      </fieldset>
      <div class="md:col-span-2">
        <button
          class="inline-flex items-center rounded-md bg-slate-900 px-4 py-2 text-sm font-medium text-white shadow-sm transition hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-offset-2"
          type="submit"
        >
          Query starten
        </button>
      </div>
    </form>
    <div class="mt-6 space-y-2">
      <h3 class="text-sm font-semibold uppercase tracking-wide text-slate-600">Query Response</h3>
      <pre class="max-h-96 overflow-auto rounded-lg bg-slate-950 p-4 text-xs text-slate-100" id="query-response"></pre>
    </div>
  </section>
</div>

<script>
  (function () {
    const derivedTenantId = "{{ tenant_id|escapejs }}";
    const tenantId = derivedTenantId || window.location.hostname || "dev.localhost";
    const defaultEmbeddingProfile = "{{ default_embedding_profile|escapejs }}" || "standard";
    const baseHeaders = {
      'X-Tenant-ID': tenantId,
      'X-User-ID': 'local',
      'X-Case-ID': 'local'
    };
    let lastRunId = null;

    function getCsrfToken() {
      const match = document.cookie.match(/(?:^|; )csrftoken=([^;]+)/);
      return match ? decodeURIComponent(match[1]) : null;
    }

    function renderJson(target, value) {
      const element = document.getElementById(target);
      if (!element) return;
      element.textContent = value;
    }

    function prettyPrint(target, data) {
      renderJson(target, JSON.stringify(data, null, 2));
    }

    function updateLastRunId(runId) {
      if (!runId) {
        return;
      }
      lastRunId = runId;
      const display = document.getElementById('last-run-id');
      if (display) {
        display.textContent = runId;
      }
    }

    const uploadForm = document.getElementById('upload-form');
    const uploadResponseTarget = 'upload-response';
    if (uploadForm) {
      uploadForm.addEventListener('submit', async function (event) {
        event.preventDefault();
        const fileInput = document.getElementById('upload-file');
        const metadataInput = document.getElementById('upload-metadata');
        if (!fileInput || !(fileInput instanceof HTMLInputElement) || !fileInput.files?.length) {
          renderJson(uploadResponseTarget, 'Please choose a file to upload.');
          return;
        }

        const formData = new FormData();
        formData.append('file', fileInput.files[0]);
        if (metadataInput && metadataInput.value.trim()) {
          formData.append('metadata', metadataInput.value.trim());
        }

        const headers = { ...baseHeaders };
        const csrfToken = getCsrfToken();
        if (csrfToken) {
          headers['X-CSRFToken'] = csrfToken;
        }

        try {
          const response = await fetch('/ai/rag/documents/upload/', {
            method: 'POST',
            headers,
            body: formData,
            credentials: 'include'
          });
          const text = await response.text();
          try {
            const data = JSON.parse(text);
            prettyPrint(uploadResponseTarget, data);
            if (data && typeof data === 'object' && data.ingestion_run_id) {
              updateLastRunId(data.ingestion_run_id);
            }
          } catch (err) {
            renderJson(uploadResponseTarget, text);
          }
        } catch (error) {
          renderJson(uploadResponseTarget, String(error));
        }
      });
    }

    const ingestionForm = document.getElementById('ingestion-form');
    const ingestionResponseTarget = 'ingestion-response';
    if (ingestionForm) {
      ingestionForm.addEventListener('submit', async function (event) {
        event.preventDefault();
        const docInput = document.getElementById('ingestion-document-ids');
        if (!docInput || !(docInput instanceof HTMLTextAreaElement)) {
          renderJson(ingestionResponseTarget, 'Document input not found.');
          return;
        }
        const rawValue = docInput.value.trim();
        if (!rawValue) {
          renderJson(ingestionResponseTarget, 'Bitte mindestens eine document_id angeben.');
          return;
        }
        const docs = rawValue
          .split(/[\n,]/)
          .map(function (entry) { return entry.trim(); })
          .filter(function (entry) { return Boolean(entry); });
        if (!docs.length) {
          renderJson(ingestionResponseTarget, 'Bitte gültige document_ids angeben.');
          return;
        }

        const profileSelect = document.getElementById('ingestion-profile');
        const selectedProfile =
          profileSelect && profileSelect instanceof HTMLSelectElement && profileSelect.value.trim()
            ? profileSelect.value.trim()
            : defaultEmbeddingProfile;

        const payload = {
          document_ids: docs,
          embedding_profile: selectedProfile,
        };

        const headers = {
          ...baseHeaders,
          'Content-Type': 'application/json',
          Accept: 'application/json'
        };
        const csrfToken = getCsrfToken();
        if (csrfToken) {
          headers['X-CSRFToken'] = csrfToken;
        }

        try {
          const response = await fetch('/ai/rag/ingestion/run/', {
            method: 'POST',
            headers,
            body: JSON.stringify(payload),
            credentials: 'include'
          });
          const text = await response.text();
          try {
            const data = JSON.parse(text);
            prettyPrint(ingestionResponseTarget, data);
            if (data && typeof data === 'object' && data.ingestion_run_id) {
              updateLastRunId(data.ingestion_run_id);
            }
          } catch (err) {
            renderJson(ingestionResponseTarget, text);
          }
        } catch (error) {
          renderJson(ingestionResponseTarget, String(error));
        }
      });
    }

    const statusResponseTarget = 'status-response';

    async function refreshStatus() {
      const headers = {
        ...baseHeaders,
        Accept: 'application/json'
      };
      const csrfToken = getCsrfToken();
      if (csrfToken) {
        headers['X-CSRFToken'] = csrfToken;
      }

      try {
        const response = await fetch('/ai/rag/ingestion/status/', {
          method: 'GET',
          headers,
          credentials: 'include'
        });
        const text = await response.text();
        try {
          const data = JSON.parse(text);
          prettyPrint(statusResponseTarget, data);
          if (data && typeof data === 'object' && data.run_id) {
            updateLastRunId(data.run_id);
          }
        } catch (err) {
          renderJson(statusResponseTarget, text);
        }
      } catch (error) {
        renderJson(statusResponseTarget, String(error));
      }
    }

    const statusButton = document.getElementById('status-refresh');
    if (statusButton) {
      statusButton.addEventListener('click', refreshStatus);
    }

    const queryForm = document.getElementById('query-form');
    const queryResponseTarget = 'query-response';
    if (queryForm) {
      queryForm.addEventListener('submit', async function (event) {
        event.preventDefault();
        const queryText = document.getElementById('query-text');
        if (!queryText || !(queryText instanceof HTMLTextAreaElement)) {
          renderJson(queryResponseTarget, 'Query input not found.');
          return;
        }
        const queryValue = queryText.value.trim();
        if (!queryValue) {
          renderJson(queryResponseTarget, 'Please enter a query.');
          return;
        }

        const payload = {
          query: queryValue,
          question: queryValue,
          hybrid: {}
        };

        const processInput = document.getElementById('query-process');
        if (processInput && processInput.value.trim()) {
          payload.process = processInput.value.trim();
        }
        const docClassInput = document.getElementById('query-doc-class');
        if (docClassInput && docClassInput.value.trim()) {
          payload.doc_class = docClassInput.value.trim();
        }
        const visibilitySelect = document.getElementById('query-visibility');
        if (visibilitySelect && visibilitySelect.value) {
          payload.visibility = visibilitySelect.value;
        }

        const hybridFields = [
          { id: 'hybrid-alpha', key: 'alpha', parse: parseFloat },
          { id: 'hybrid-min-sim', key: 'min_sim', parse: parseFloat },
          { id: 'hybrid-top-k', key: 'top_k', parse: function (value) { return parseInt(value, 10); } },
          { id: 'hybrid-vec-limit', key: 'vec_limit', parse: function (value) { return parseInt(value, 10); } },
          { id: 'hybrid-lex-limit', key: 'lex_limit', parse: function (value) { return parseInt(value, 10); } },
          { id: 'hybrid-max-candidates', key: 'max_candidates', parse: function (value) { return parseInt(value, 10); } },
          { id: 'hybrid-trgm-limit', key: 'trgm_limit', parse: parseFloat }
        ];

        hybridFields.forEach(function (field) {
          const input = document.getElementById(field.id);
          if (!input || !(input instanceof HTMLInputElement)) {
            return;
          }
          const value = input.value.trim();
          if (!value) {
            return;
          }
          const numberValue = field.parse(value);
          if (!Number.isFinite(numberValue)) {
            return;
          }
          payload.hybrid[field.key] = numberValue;
        });

        const headers = {
          ...baseHeaders,
          'Content-Type': 'application/json',
          Accept: 'application/json'
        };
        const csrfToken = getCsrfToken();
        if (csrfToken) {
          headers['X-CSRFToken'] = csrfToken;
        }

        try {
          const response = await fetch('/ai/rag/query/', {
            method: 'POST',
            headers,
            body: JSON.stringify(payload),
            credentials: 'include'
          });
          const text = await response.text();
          try {
            const data = JSON.parse(text);
            prettyPrint(queryResponseTarget, data);
          } catch (err) {
            renderJson(queryResponseTarget, text);
          }
        } catch (error) {
          renderJson(queryResponseTarget, String(error));
        }
      });
    }
  })();
</script>
{% endblock %}
